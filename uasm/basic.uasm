

; 
; \       XXXXXXXX
; X\      XXXXXXXX
; XX\     XXXXXXXX
; XXX\    XXXXXXXX
; XXXX\   XXXXXXXX       BBBBBB      AA      SSSSSS  IIIIII    CCCCC
; XXXXX\  XXXXXXXX       BB   BB    AAAA    SS         II     CC   CC
; XXXXXX\ XXXXXXXX       BB  BB    AA  AA   SS         II     CC
; XXXXXXX\XXXXXXXX       BBBBB     AA  AA    SSSS      II     CC
; \                      BB  BB    AAAAAA       SS     II     CC
; X\                     BB   BB  AA    AA       SS    II     CC
; XX\                    BB   BB  AA    AA       SS    II     CC   CC
; XXX\                   BBBBBB   AA    AA  SSSSSS   IIIIII    CCCCC
; XXXX\
; XXXXX\
; XXXXXX\ 
; XXXXXXX\
;
; Version 0.6
;
; Univtek BASIC for Univtek 020 (U020)
; incl. Univtek DOS
; written by Univtek Corp 
; ("Univtek Team")
;
; Copyright (c) 2017-2018 "Univtek Team"
; 
; Permission is hereby granted, free of charge, to any person obtaining
; a copy of this software and associated documentation files (the
; "Software"), to deal in the Software without restriction, including
; without limitation the rights to use, copy, modify, merge, publish,
; distribute, sublicense, and/or sell copies of the Software, and to
; permit persons to whom the Software is furnished to do so, subject to
; the following conditions:
; 
; The above copyright notice and this permission notice shall be included
; in all copies or substantial portions of the Software.
; 
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
; IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
; CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
; TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
; SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
; 

; SYS vectors:
;       Hide cursor temporarily:
;           SYS&183D        (hide_cursor_simple)
;       Repatch font from 0xF300:
;           SYS&17F1        (repatch_font)

; ===========================
; STARTUP
; ===========================

.org 0x0000     
                ; $0000: initial jump
    SET PC, basic_main
                ; $0002: unused 2 words

; ===========================
; HEAP
; ===========================

.org 0x0004
:LLTMPW         ; $0004: temp space for low level routines
    DAT 0
:JUMPING        ; $0005: whether jumping
    DAT 0
:USRADDR        ; $0006: address called by USR()
    DAT 0
:ARRAYDIM       ; $0007: whether to read dimension from STR3+255
    DAT 0
:DATAPTR        ; $0008: DATA pointer
    DAT 0
:DATASTMT       ; $0009: whether in DATA statement
    DAT 0
:NEXTFLG        ; $000A: "NEXT" flag for tokenizer
    DAT 0
:LOOPSP         ; $000B: LOOP_STACK stack pointer
    DAT 0
:NOARRAY        ; $000C: whether to disallow arrays in exec_var
    DAT 0
:COPYDOS        ; $000D: warm reset flag, 0 for cold reset
    DAT 0
:INPUTORIG      ; $000E: original Z position when reading INPUT
    DAT 0       ;        to allow REDO
:INPUTPOS       ; $000F: whether reading first input
    DAT 0       

.org 0x0014     
                ; $0014, dec 020: credits routine
:CREDITS_JUMP_020
    SET PC, jsr_credits

.org 0x0020
:RND_SEED       ; $0020: random number generator seed
    DAT 0, 0
:RND_CALLED     ; $0022: whether random number generator has
                ; been called (if not, alter SEED for initial call)
    DAT 0

.org 0x0030
:ATMP           ; $0030: temporary memory space for BASIC routines
    DAT 0, 0, 0, 0, 0, 0, 0, 0
    DAT 0, 0, 0, 0, 0, 0, 0, 0

.org 0x0040
:BTMP           ; $0040: temporary memory space for BASIC routines
    DAT 0, 0, 0, 0, 0, 0, 0, 0
    DAT 0, 0, 0, 0, 0, 0, 0, 0
:FTMP           ; $0050: temporary memory space for FP functions
    DAT 0, 0, 0, 0, 0, 0, 0, 0
    DAT 0, 0, 0, 0, 0, 0, 0, 0
:VMEMSPTR       ; $0060: beginning of variable area in memory
    DAT PROG_DATA
:VMEMFPTR       ; $0061: beginning of free space in variable/string/array heap
    DAT PROG_DATA
:VMEMEND        ; $0062: end of BASIC memory space
    DAT MEM_END

; Program memory (see PMEM*) is stored in DCPU-16 UNEM192 page 0 (conventional),
; while variable heap is under page 1.

:RUNNING        ; $0063: 0 if not running code, 
                ; 1 if continue possible, 0xFFFF if running
    DAT 0
:RUNLINE        ; $0064: address to code line that's being run
    DAT 0
:VARLIST        ; $0065: linked list to variables, _ to A to Z, 
                ;   value $0000 = no variables
    DAT 0       ; _
    DAT 0, 0, 0, 0, 0, 0   ; A-F
    DAT 0, 0, 0, 0, 0, 0   ; G-L
    DAT 0, 0, 0, 0, 0, 0   ; M-R
    DAT 0, 0, 0, 0, 0, 0   ; S-X
    DAT 0, 0               ; Y-Z

; Variable linked list structure
;
;Variable   $0000       $0010 Int, $0011 Float, $0012 String, 
;                       $0020 Int Array, $0021 Float Array, $0022 String Array
;           $0001       Pointer to next element (0 if no more)
;           $0002       X = variable name length (1-15)
;           $0003       Variable name
;           $X+03       ... Int, Float, String, Array
;
; (functions are stored in variable space as variables within linked lists)
;Function   $0000       $0030
;           $0001       Pointer to next element (0 if no more)
;           $0002       X = variable name length (1-15)
;           $0003       Variable name
;           $X+03       Address to code with expression
;           $X+04       Line numer of code with expression
;           $X+05       function parameter name length (1-15)
;           $X+06       Function parameter name
;
;Int        $0000       iiiiiiiiiiiiiiii
;           $0001       siiiiiiiiiiiiiii
;           $0002       -
;           $0003       -
;
;Float      $0000       eeeeeeeesmmmmmmm        (storage FP)
;           $0001       mmmmmmmmmmmmmmmm        (e=0 ? v = 0.0)
;           $0002       mmmmmmmmmmmmmmmm        (    : v = (2s-1)m*2^(e-128))
;           $0003       -
;
;String     $0000       --------LLLLLLLL (length of string)
;           $0001...    00000000cccccccc ()
;
;Array      $0000       --------nnnnnnnn (number of dimensions in total)
;           $0001...    --------aaaaaaaa (upper bound of dimension, 0 = 1 element)
;           $X          Int, Float, String...

:FP0            ; $0080: floating point value 0
                ; $0000       exponent (lo byte only, 00: v=0.0, 01-FF: 
                ;                       e=-127..+127, v=m*2^e)
                ; $0001       sign (0000 for positive, FFFF for negative)
                ; $0002       mantissa high
                ; $0003       mantissa lo
                ; $0004       mantissa rounding
    DAT 0, 0, 0, 0, 0
:FP1            ; $0085: floating point value 1
    DAT 0, 0, 0, 0, 0
:FP2            ; $008A: floating point value 2
    DAT 0, 0, 0, 0, 0
:FPT            ; $008F: floating point temp value
    DAT 0, 0, 0, 0, 0
:FPERROR        ; $0094: floating point error flag
                            ; $0000 = no error
                            ; $0001 = overflow (too large magnitude)
                            ; $0002 = divide by zero
                            ; $0003 = range error
    DAT 0
:DIRECTFLG      ; $0095: non-zero if current statement in direct mode
    DAT 0
:RESULTLN       ; $0096: line number for current parsed statement
    DAT 0
:PMEMSPTR       ; $0097: beginning of program area in memory
    DAT PROG_DATA
:PMEMFPTR       ; $0098: beginning of free space in program area
    DAT PROG_DATA
:PMEMEND        ; $0099: end of BASIC program memory space
    DAT MEM_END
:STR2LEN        ; $009A: length of tokenized string
    DAT 0
:BREAKFLG       ; $009B: non-zero if breaking
    DAT 0
:CURLINE        ; $009C: current line number
    DAT 0
:EXECPTR        ; $009D: statement execution pointer
    DAT 0
:EXPRERR        ; $009E: expression error flag
    DAT 0
:EXPRSP         ; $009F: EXPR_STACK stack pointer
    DAT 0

                ; $00A0: device addresses

:DEVDISP        ; $00A0: display (UNPC321)
    DAT 0
:DEVKEYB        ; $00A1: generic keyboard
    DAT 0
:DEVDISK        ; $00A2: M35FD 3.5" Floppy Drive
    DAT 0
:DEVMEM         ; $00A3: UNEM192 Extra RAM
    DAT 0
:DEVLPT         ; $00A4: UNPR170 Text Printer
    DAT 0

.org 0x00B0     
                ; $00B0: I/O and device info

:DISPMASK       ; $00B0: display mask (BG & FG color)
    DAT 0xF000
:DISPCURSOR     ; $00B1: position of cursor
    DAT 0xFFFF

.org 0x00C0
:readyflag      ; $00C0: whether to print READY message
    DAT 0
    DAT 0

.org 0x00C8
:SYS_REG        ; $00C8: position for registers [A, B, C, X, Y, Z, I, J]
    DAT 0, 0, 0, 0, 0, 0, 0, 0
                ; dec: 200-207

.org 0x00D0

:VARTYPE        ; $00D0: variable type
                ; $0010 Int $0011 Float $0012 String
                ; Arrays: $0020 Int $0021 Float $0022 String
    DAT 0
:VARNAME        ; $00D1: variable name buffer
                ; 15 characters at most
    DAT 0, 0, 0, 0, 0
    DAT 0, 0, 0, 0, 0
    DAT 0, 0, 0, 0, 0
:VARLEN         ; $00E0: length of VARNAME
    DAT 0

.org 0x00EF
:VARBACKUP      ; backup for VARTYPE, VARNAME, VARLEN
                ; used by various statements
    DAT 0, 0, 0, 0, 0
    DAT 0, 0, 0, 0, 0
    DAT 0, 0, 0, 0, 0
    DAT 0, 0, 0, 0, 0
    DAT 0, 0, 0, 0, 0
    DAT 0, 0


.org 0x0400
:LINEBUF        ; $0400: current line for BASIC interpreter
.org 0x0500
:STR1           ; $0500: string buffer 1 (I/O)
.org 0x0700
:STR2           ; $0700: string buffer 2 (BASIC tokenized line buffer)
.org 0x0900
:STR3           ; $0900: string buffer 3 (floating point)
.org 0x0B00
:VRAM           ; $0B00: video memory, enough space for mode 0 and 1

.org 0x1700

; ===========================
; SCREEN OUTPUT (DOS)
; ===========================

; Print text at I to screen at the position of the text cursor
; (null terminated)
; see chrout for info
:txtout        
    IFE [I], 0
        SET PC, tail_inc_i
    SET PUSH, J
:txtout_loop
    SET A, [I]
    JSR chrout
    ADD I, 1
    IFN [I], 0
        SET PC, txtout_loop
    SET J, POP
    SET PC, POP

:txtnout_tmp
    DAT 0
; Print text at I to screen at the position of the text cursor
; prints A characters
; see chrout for info
:txtnout        
    SET [txtnout_tmp], A
    SET PUSH, J
:txtnout_loop
    IFE [txtnout_tmp], 0
        SET PC, txtnout_end
    SET A, [I]
    JSR chrout
    ADD I, 1
    SUB [txtnout_tmp], 1
    SET PC, txtnout_loop
:txtnout_end
    SET J, POP
    SET PC, POP

:scrlup_tmp
    DAT 0
; Scroll the screen up by a line
; Uses registers I and J
:scrlup
    SET PUSH, I
    ADD [scrlup_tmp], 1
    SET [DISPCURSOR], 576
    SET I, 32+VRAM
    SET J, VRAM
:scrlup_loop
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    IFL J, 608+VRAM
        SET PC, scrlup_loop
    SET I, POP
    SET PC, POP

; Print character A at cursor position
; A high byte should NOT be set (0x0000 : 0x00FF)
; modifies DISPCURSOR
; Supported characters (all other chars ignored)
;     0x0009: TAB (to next 4 characters)
;     0x000D: next line
;     0x0010: Backspace (remove char, cursor back)
;     0x0011: place 0xFFFF, next line
;     0x0020: ASCII
;              ...
;     0x007E: ASCII
;     0x0080: move cursor up
;     0x0081: move cursor down
;     0x0082: move cursor left
;     0x0083: move cursor right
;     0x00A0: CP437
;              ...
;     0x00FF: CP437
; uses the J register

:chrout
    SET [scrlup_tmp], 0
    SET J, [DISPCURSOR]
    ADD J, VRAM
    IFE A, 0x0180
        SET PC, chrout_aup
    IFE A, 0x0181
        SET PC, chrout_adn
    IFE A, 0x0182
        SET PC, chrout_alt
    IFE A, 0x0183
        SET PC, chrout_art
    AND A, 0x00FF
    IFE A, 0x0009
        SET PC, chrout_tab
    IFE A, 0x000D
        SET PC, chrout_nl
    IFE A, 0x0010
        SET PC, chrout_bksp
    IFE A, 0x0011
        SET PC, chrout_enter
    IFE A, 0x0016
        SET PC, chrout_inphed
    IFG A, 0x001F
        IFL A, 0x00FF
            SET PC, chrout_chr
    IFG A, 0x009F
        SET PC, chrout_chr
    SET PC, POP
:chrout_chr    
    BOR A, [DISPMASK]
    SET [J], A
    ADD [DISPCURSOR], 1
    IFG [DISPCURSOR], 607   ; end of screen
        JSR scrlup
    SET PC, update_cursor

:chrout_bksp
    SET [0xFFFF+J], [DISPMASK]
    IFL [DISPCURSOR], 1
        SET PC, POP
    SUB [DISPCURSOR], 1
    SET PC, update_cursor

:chrout_tab
    ADD [DISPCURSOR], 8
    AND [DISPCURSOR], 0xFFF8
    IFG [DISPCURSOR], 607   ; end of screen
        JSR scrlup
    SET PC, update_cursor

:chrout_inphed
    SET A, 0x00FF
    SET PC, chrout_chr

:chrout_enter
    SET [J], 0x00FF
    BOR [J], [DISPMASK]
:chrout_nl
    ADD [DISPCURSOR], 32
    AND [DISPCURSOR], 0xFFE0
    IFG [DISPCURSOR], 607   ; end of screen
        JSR scrlup
    SET PC, update_cursor

:chrout_aup
    IFL [DISPCURSOR], 32
        SET PC, POP
    SUB [DISPCURSOR], 32
    SET PC, update_cursor

:chrout_adn
    IFG [DISPCURSOR], 575
        SET PC, POP
    ADD [DISPCURSOR], 32
    SET PC, update_cursor

:chrout_alt
    IFL [DISPCURSOR], 1
        SET PC, POP
    SUB [DISPCURSOR], 1
    SET PC, update_cursor

:chrout_art
    IFG [DISPCURSOR], 606
        SET PC, POP
    ADD [DISPCURSOR], 1
    SET PC, update_cursor

; Draws a raw character, including color.
; Does not handle special characters like $0011!
:chrCout
    SET J, DISPCURSOR
    ADD J, VRAM
    SET [J], A
    ADD [DISPCURSOR], 1
    IFG [DISPCURSOR], 607   ; end of screen
        JSR scrlup
    SET PC, update_cursor

; ===========================
; DOS / BASIC SWITCHER
; ===========================

:DOS_CALL
    JSR rnd_inc
    SUB [DOS_CALL], 0x6000  ; DOS code is assembled
                            ; at 0x8000 and stored
                            ; at 0x2000
:DOS_CALL_RAW
    SET PUSH, A
    SET PUSH, B
    SET A, 1
    ; 0x2000-0x6FFF: DOS
    SET B, 0b0000000001111100
    HWI [DEVMEM]
    SET B, POP
    SET A, POP
    DAT 0x7c20              ; JSR ...
:DOS_CALL_ADDR
    DAT 0                   ; where to call DOS
    ; 0x2000-0x6FFF: BASIC
    SET PUSH, A
    SET PUSH, B
    SET A, 1
    SET B, 0b0000000000000000
    HWI [DEVMEM]
    SET B, POP
    SET A, POP
    SET PC, POP

; ===========================
; HARDWARE INTERFACE
; ===========================

; Font repatch
:repatch_font
    SET A, 1
    SET B, 0xF300
    HWI [DEVDISP]
    SET PC, POP

; Device finding subroutine
; 
; Parameters
;       A = Device ID low
;       B = Device ID high
;
; Return values
;       Z = Hardware device number
;           0xFFFF if not found. 
;           If not 0xFFFF, below values also defined:
;               A = Device ID low
;               B = Device ID high
;               C = Device version
;               X = Device manufacturer low
;               Y = Device manufacturer high

:dev_id_lo    DAT 0
:dev_id_hi    DAT 0

:device_find
    SET [dev_id_lo], A
    SET [dev_id_hi], B
    HWN Z
:device_find_loop
    IFE Z, 0
        SET PC, device_find_fail
    SUB Z, 1
    HWQ Z
    JSR rnd_inc
    IFN A, [dev_id_lo]
        SET PC, device_find_loop
    IFN B, [dev_id_hi]
        SET PC, device_find_loop
    SET PC, POP
:device_find_fail
    SET Z, 0xFFFF
    SET PC, POP

:device_smart_find
    JSR device_find
    IFE Z, 0xFFFF
        SET PC, crash
    SET [I], Z
    SET PC, POP

:crash
    SET PC, crash

:reset_screen
    SET A, 0        ; screen
    SET B, VRAM
    HWI [DEVDISP]
    SET A, 6        
    SET B, 0
    HWI [DEVDISP]
    SET I, VRAM
    SET J, 0
:reset_screen_loop
    STI [I], [DISPMASK] ; char 0
    STI [I], [DISPMASK]
    STI [I], [DISPMASK]
    STI [I], [DISPMASK]
    IFL J, 640          ; 32 * 19
        SET PC, reset_screen_loop
:hide_cursor
    SET [DISPCURSOR], 0xFFFF
:update_cursor
    SET PUSH, A
    SET PUSH, B
    SET A, 8
    SET B, [DISPCURSOR]
    HWI [DEVDISP]
    SET B, POP
    SET A, POP
    SET PC, POP

:hide_cursor_simple
    SET PUSH, A
    SET PUSH, B
    SET A, 8
    SET B, 0xFFFF
    HWI [DEVDISP]
    SET B, POP
    SET A, POP
    SET PC, POP

; ===========================
; MAIN LOOP
; ===========================

:basic_main

    SET A, 0x4b47
    SET B, 0xca1c
    SET I, DEVMEM
    JSR device_smart_find

    IFE [COPYDOS], 0
        SET PC, no_copy_dos
    SET A, 1
    ; 0x2000-0x6FFF: DOS
    SET B, 0b0000000001111100
    HWI [DEVMEM]
    SET I, DOS_START
    SET J, 0x2000
:copy_dos_loop
    IFE I, DOS_END
        SET PC, copy_dos_done
    STI [J], [I]
    SET PC, copy_dos_loop
:copy_dos_done
    SET A, 1
    SET B, 0b0000000000000000
    HWI [DEVMEM]
    JSR fast_copy_block_f
:no_copy_dos
    SET [COPYDOS], 0xD16B

:cold_boot

; FIND DEVICES

    SET A, 0x373e
    SET B, 0xdb7b
    SET I, DEVDISP
    JSR device_smart_find

    SET A, 0x7406
    SET B, 0x30cf
    SET I, DEVKEYB
    JSR device_smart_find

    ;SET A, 0x24c5
    ;SET B, 0x4fd5
    SET I, DEVDISK
    JSR device_smart_find

    ; PRINTER NOT YET IMPLEMENTED
    ;SET A, 0xa436
    ;SET B, 0xdae1
    SET I, DEVLPT
    JSR device_smart_find

; SETUP DEVICES

    SET A, 4
    SET B, 0xF300
    HWI [DEVDISP]

; RESET MEMORY (COLD)

:warm_boot

; RESET MEMORY (WARM)

    SET A, 0
    HWI [DEVKEYB]
    SET [DISPMASK], 0xB000
    SET [USRADDR], exec_expr_illegalarg

    JSR reset_screen
    SET [DISPCURSOR], 0x0000 ; top left cursor
    SET I, msg_welcome
    JSR txtout

    JSR BASIC_NEW_RAW

    JSR freesp
    JSR int_str
    SET I, STR3
    JSR txtout
    
    SET I, msg_freemem
    JSR txtout

    JSR BASIC_NEW

; ===========================
; MAIN LOOP
; ===========================

:repl_loop
    IFE [readyflag], 0
        SET PC, repl_loop_nmsg
    SET I, msg_ready
    JSR txtout
    SET [readyflag], 0
:repl_loop_nmsg

    SET [BREAKFLG], 0
    JSR readln
    IFE [BREAKFLG], 0
        JSR parseln
    SET PC, repl_loop

; ===========================
; GENERAL UTILITIES
; ===========================

; Increase I, return
:tail_inc_i
    ADD I, 1
; Does nothing, placeholder
:NOOP_SR
    SET PC, POP    

; Copy block backwards from I to J
; until I == A
:copy_block_b
    IFE I, A
        SET PC, POP
    STD [J], [I]
    SET PC, copy_block_b

; Copy block forwards from I to J
; until I == A
:copy_block_f
    IFE I, A
        SET PC, POP
    STI [J], [I]
    SET PC, copy_block_f

; Block copy with C (forward)
:copy_block_c
    IFE C, 0
        SET PC, POP
    STI [J], [I]
    SUB C, 1
    SET PC, copy_block_c

; Copy block backwards from I to J
; I and J are first words instead of last, adjusting
:fast_copy_block_b_a
    ADD I, C
    ADD J, C
    STD 0, 0            ; dec I and J
; Copy block backwards from I to J
; copies C words, partially unrolled
:fast_copy_block_b
    IFE C, 0
        SET PC, POP
    IFL C, 3
        SET PC, fast_copy_block_b1
    IFL C, 7
        SET PC, fast_copy_block_b3
    IFL C, 15
        SET PC, fast_copy_block_b7
    IFL C, 31
        SET PC, fast_copy_block_b15
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    SUB C, 16
:fast_copy_block_b15
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    SUB C, 8
:fast_copy_block_b7
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    STD [J], [I]
    SUB C, 4
:fast_copy_block_b3
    STD [J], [I]
    STD [J], [I]
    SUB C, 2
:fast_copy_block_b1
    STD [J], [I]
    SUB C, 1
    SET PC, fast_copy_block_b

; Fill C words with A starting from I
:mem_fill
    IFE C, 0
        SET PC, POP
    SET [I], A
    ADD I, 1
    SUB C, 1
    SET PC, mem_fill

; Copy block forwards from I to J
; copies C words, partially unrolled
:fast_copy_block_f
    IFE C, 0
        SET PC, POP
    IFL C, 3
        SET PC, fast_copy_block_f1
    IFL C, 7
        SET PC, fast_copy_block_f3
    IFL C, 15
        SET PC, fast_copy_block_f7
    IFL C, 31
        SET PC, fast_copy_block_f15
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    SUB C, 16
:fast_copy_block_f15
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    SUB C, 8
:fast_copy_block_f7
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    STI [J], [I]
    SUB C, 4
:fast_copy_block_f3
    STI [J], [I]
    STI [J], [I]
    SUB C, 2
:fast_copy_block_f1
    STI [J], [I]
    SUB C, 1
    SET PC, fast_copy_block_f

:jsr_credits
    SET A, 0x11
    JSR chrout
    SET A, 0x11
    JSR chrout
    SET I, [DISPCURSOR]
    ADD I, VRAM
    SET [I+0xFFE0], 0xF01D
    SET [I+0xFFE1], 0xFF20
    SET [I], 0xF01D
    SET [I+1], 0xF020
    ADD [DISPCURSOR], 2
    SET A, 0x11
    JSR chrout
    SET A, 0x11
    JSR chrout
    SET I, msg_credits
    JSR txtout
    SET PC, POP

:rnd_inc
    IFN [RND_CALLED], 0
        SET PC, POP
    ADX [RND_SEED+1], 1
    ADX [RND_SEED], 0
    SET PC, POP

:VARDATA_STK_C
    DAT 0
:VARDATA_STK_I
    DAT 0
:VARDATA_TO_STK
    SET [VARDATA_STK_C], C
    SET [VARDATA_STK_I], I
    SET A, POP
    SET C, [VARLEN]
    SET I, VARNAME
    ADD I, C
:VARDATA_TO_STK_LOOP
    SUB I, 1
    SET PUSH, [I]
    SUB C, 1
    IFG C, 0
        SET PC, VARDATA_TO_STK
    SET PUSH, [VARLEN]
    SET PUSH, [VARTYPE]
    SET I, [VARDATA_STK_I]
    SET C, [VARDATA_STK_C]
    SET PC, A

:VARDATA_FROM_STK
    SET [VARDATA_STK_C], C
    SET [VARDATA_STK_I], I
    SET A, POP
    SET [VARTYPE], POP
    SET [VARLEN], POP
    SET C, [VARLEN]
    SET I, VARNAME
:VARDATA_FROM_STK_LOOP
    SET [I], POP
    ADD I, 1
    SUB C, 1
    IFG C, 0
        SET PC, VARDATA_TO_STK
    SET I, [VARDATA_STK_I]
    SET C, [VARDATA_STK_C]
    SET PC, A

; ===========================
; MEMORY
; ===========================

; Return amount of free space in A,B
:freesp
    SET B, 0
    SET A, [VMEMEND]
    SUB A, [VMEMFPTR]
    SET C, [PMEMEND]
    SUB C, [PMEMFPTR]
    ADD A, C
    ADX B, 0
    SET PC, POP

:breaktrig_input
    SET A, 0x11
    JSR chrout
:breaktrig_reset
    SET SP, 0
:breaktrig
    SET I, msg_break
    JSR txtout
    SET [BREAKFLG], 0xFFFF
    IFN [RUNNING], 0
        SET [RUNNING], 1
    SET PC, repl_loop

; ===========================
; INPUT AND OUTPUT
; ===========================

; Read line
; I represents the beginning of the line
; line ends in 0xF0FF
; line is discarded if Delete pressed (Delete = Break)
; uses A, C, I
:readln
    JSR rnd_inc
    SET A, 1
    HWI [DEVKEYB]
    IFE C, 0x00
        SET PC, readln
    IFE C, 0x11
        SET PC, readln_end
    IFE C, 0x12
        SET PC, readln
    IFE C, 0x13
        SET PC, breaktrig_input
    IFE C, 0x0190
        SET PC, readln
    IFE C, 0x0191
        SET PC, readln
    IFE C, 0x0192
        SET PC, readln_univtek
    SET A, C
    JSR chrout
    SET PC, readln
:readln_end
    SET I, [DISPCURSOR]
    ADD I, VRAM
:readln_endch
    SET A, [DISPMASK]
    BOR A, 0x0020
    IFE [I], A
        SET PC, readln_sprem
    SET A, [DISPMASK]
    BOR A, 0x00FF
; find 0x0000 or 0x00FF
:readln_loop
    IFE I, VRAM
        SET PC, readln_force
    SUB I, 1
    SET A, [I]
    AND A, 0x00FF
    IFN A, 0x0000
        IFN A, 0x00FF
            SET PC, readln_loop
:readln_force                
    ADD I, 1
    SET PUSH, I
    SET A, 0x11
    JSR chrout
    SET I, POP
    IFN [scrlup_tmp], 0
        SUB I, 32
    SET PC, POP

:readln_sprem
    SET [I], 0x00FF
    BOR [I], [DISPMASK]
    SUB I, 1
    SET PC, readln_endch    

:readln_univtek
    ; check if Ctrl pressed
    SET PUSH, A
    SET PUSH, B
    SET PUSH, C
    SET A, 2
    SET B, 0x0191           ; <CTRL>
    HWI [DEVKEYB]
    IFN C, 0
        SET PC, readln_univtek_cold_reset
    SET C, POP
    SET B, POP
    SET A, POP
    SET PC, readln

:readln_univtek_cold_reset
    SET A, 0x2739
    HWI [DEVKEYB]           ; cold reset

; Print value in A as 4 digit HEX
:hexout
    SET [LLTMPW], A
    SHR A, 12
    AND A, 0xF
    ADD A, 0x30
    IFG A, 0x39
        ADD A, 0x07
    JSR chrout
    SET A, [LLTMPW]
    SHR A, 8
    AND A, 0xF
    ADD A, 0x30
    IFG A, 0x39
        ADD A, 0x07
    JSR chrout
    SET A, [LLTMPW]
    SHR A, 4
    AND A, 0xF
    ADD A, 0x30
    IFG A, 0x39
        ADD A, 0x07
    JSR chrout
    SET A, [LLTMPW]
    AND A, 0xF
    ADD A, 0x30
    IFG A, 0x39
        ADD A, 0x07
    JSR chrout
    SET PC, POP

; ===========================
; TOKENIZER
; ===========================

; Z = input pointer
; Skip until no more spaces
:skipspc_inc
    ADD Z, 1
:skipspc
    IFE [Z], 0x0020
        SET PC, skipspc_inc
    SET PC, POP

; Z = input pointer
; Skip until no more spaces
:skipspc_disp
    SET A, 0x0020
    BOR A, [DISPMASK]
    SUB Z, 1
:skipspc_disp_inc
    ADD Z, 1
    IFE [Z], A
        SET PC, skipspc_disp_inc
    SET PC, POP

; Parse & run line
; Line address: I
; Line ends in 0x00FF
:parseln
    SET [DIRECTFLG], 0
    SET [RESULTLN], 0
    SET Z, I
    JSR skipspc_disp
    SET A, [Z]
    AND A, 0x00FF
    IFG A, 0x002F     ; "0"-1
        IFL A, 0x003A ; "9"+1
            SET PC, parseln_num
    SET [DIRECTFLG], 0xFFFF
    JSR tokenizeln
    SET Z, STR2
    SET [LOOPSP], EXPR_STACK
    SET [JUMPING], 0
    SET [DATAPTR], [PMEMSPTR]
    SET [DATASTMT], 0
    SET [NOARRAY], 0
    JSR executeln
    SET PC, POP

:parseln_num
    SET C, 0
:parseln_num_loop
    SET A, [Z]
    AND A, 0x00FF
    IFL A, 0x0030       ; "0"
        SET PC, parseln_num_end
    IFG A, 0x0039       ; "9"
        SET PC, parseln_num_end
    SET [STR1+C], A
    ADD C, 1
    ADD Z, 1
    SET PC, parseln_num_loop
:parseln_num_end
    SET [STR1+C], 0x0000
    SET A, STR1
    ADD A, C
    IFG C, 5
        SET C, 5
    SUB A, C
    JSR str_num
    IFN A, 1
        SET PC, parseln_num_end
    SET [RESULTLN], [FTMP+0]
    SET [RUNNING], 0    ; can no longer CONT
    JSR skipspc
    JSR skipspc_disp
    JSR tokenizeln
    ; copy to source code according to line number
    SET A, [PMEMEND]
    SUB A, [PMEMFPTR]
    IFG [STR2LEN], A
        SET PC, error_mem
    SET A, [RESULTLN]
    SET I, [PMEMSPTR]
    JSR line_find2_ptr
    ; STR2LEN = 1: only FFFF (end)
    IFL [STR2LEN], 2
        IFE I, [PMEMFPTR]
            SET PC, POP
    IFL [STR2LEN], 2
        IFE B, 1
            SET PC, POP
    IFL [STR2LEN], 2
        IFE B, 0
            SET PC, parseln_num_delete
    IFE I, [PMEMFPTR]
        SET PC, parseln_num_append
    IFE B, 1
        SET PC, parseln_num_bmove
    IFE B, 0
        SET PC, parseln_num_replace
    SET PC, POP

:parseln_num_append
    SET J, I
    SET [J], [RESULTLN]
    SET [J+1], [STR2LEN]
    ADD J, 2
    SET I, STR2
    SET A, STR2
    ADD A, [STR2LEN]
    ADD [PMEMFPTR], [STR2LEN]
    ADD [PMEMFPTR], 2
    SET PC, copy_block_f

:parseln_num_delete
    SET C, [I+1]
    SET J, I
    ADD I, C
    ADD I, 2
    SET A, [PMEMFPTR]
    JSR copy_block_f
    SUB [PMEMFPTR], C
    SUB [PMEMFPTR], 2
    SET PC, POP

:parseln_num_bmove
    SET C, I
    SET A, I
    SUB A, 1
    SET I, [PMEMFPTR]
    SUB I, 1
    SET J, I
    ADD J, [STR2LEN]
    ADD J, 2
    JSR copy_block_b
    ADD [PMEMFPTR], 2
    ADD [PMEMFPTR], [STR2LEN]
    SET PC, parseln_num_replace_raw

:parseln_num_replace
    SET C, I
    SET A, [STR2LEN]
    SUB A, [1+I]
    ; A > 0? move words forward
    ; A < 0? move words backward
    IFA A, 0
        SET PC, parseln_num_replace_pos
    IFU A, 0
        SET PC, parseln_num_replace_neg
:parseln_num_replace_raw
    SET [C], [RESULTLN]
    SET [C+1], [STR2LEN]
    SET J, C
    ADD J, 2
    SET I, STR2
    SET A, I
    ADD A, [STR2LEN]
    SET PC, copy_block_f

:parseln_num_replace_pos
    SET PUSH, A
    SET PUSH, I
    SET J, [PMEMFPTR]
    SUB J, 1
    SET I, J
    ADD J, A
    SET A, POP
    SUB A, 1
    JSR copy_block_b
    ADD [PMEMFPTR], POP
    SET PC, parseln_num_replace_raw

:parseln_num_replace_neg
    SET J, I
    SUB I, A
    SET PUSH, A
    SET A, [PMEMFPTR]
    JSR copy_block_f
    ADD [PMEMFPTR], POP
    SET PC, parseln_num_replace_raw

; Find line number A from the program
; Returns PMEMFPTR if not found
:line_find
    SET I, [PMEMSPTR]
; Find line number A from the program starting at program line I
; Returns PMEMFPTR if not found
:line_find_ptr
    IFG I, [PMEMFPTR]
        SET I, [PMEMFPTR]
    IFE I, [PMEMFPTR]
        SET PC, POP
    IFE [I], A
        SET PC, POP
    ADD I, [I+1]
    ADD I, 2
    SET PC, line_find_ptr

; Find line number >=A from the program starting at program line I
; Returns PMEMFPTR if not found
; B = 0 if exact line, B = 1 if >
:line_find2_ptr
    IFG I, [PMEMFPTR]
        SET I, [PMEMFPTR]
    IFE I, [PMEMFPTR]
        SET PC, POP
    IFE A, [I]
        SET PC, line_find2_eq
    IFL A, [I]
        SET PC, line_find2_gt
    ADD I, [I+1]
    ADD I, 2
    SET PC, line_find2_ptr

:line_find2_eq
    SET B, 0
    SET PC, POP    

:line_find2_gt
    SET B, 1
    SET PC, POP    

; Compare strings at I and J (both registers destroyed)
; comparing at most B characters (register also destroyed)
; A = 0x0000 if strings equal, 0xFFFF if I less, 0x0001 if I greater
:strcmp 
    SET A, 0
:strcmp_loop
    IFN A, 0
        SET PC, POP
    IFE B, 0
        SET PC, POP
    SUB B, 1
    IFL [I], [J]
        SET A, 0xFFFF
    IFG [I], [J]
        SET A, 0x0001
    STI 0, 0            ; increase I and J
    SET PC, strcmp_loop

; Check tokens (X) at source (Z)
; Return A = 0x0000 if no token found,
;        A = token code if token found, B = token length
:check_tokens
    SET A, 0
    SET B, 0
:check_tokens_loop
    IFN A, 0
        SET PC, POP
    IFE [X], 0
        SET PC, POP
    SET I, Z
    SET J, X
    ADD J, 2
    SET B, [1+X]
    JSR strcmp
    IFN A, 0
        SET A, 0xFFFF
    XOR A, 0xFFFF
    SET B, [1+X]
    IFN A, 0
        SET A, [X]
    ADD X, [X+1]
    ADD X, 2
    SET PC, check_tokens_loop

:tokenizeln
    SET [NEXTFLG], 0
    ; Z = source pointer
    ; copy string to STR1 with mask
    SET I, Z
    SET J, STR1
:tokenizeln_copy
    IFE J, STR2
        SET PC, tokenizeln_copy_end
    SET A, [I]
    AND A, 0x00FF
    IFE A, 0x00FF
        SET PC, tokenizeln_copy_end
    STI [J], A
    SET PC, tokenizeln_copy
:tokenizeln_copy_end
    IFE J, STR2
        SUB J, 1
    SET [J], 0x00FF
    SET Z, STR1
    ; Y = result pointer
    SET Y, STR2
:tokenizeln_any
    SET A, [Z]
    IFE A, 0x00FF       ; end
        SET PC, tokenizeln_end
    IFE A, 0x0020       ; <SPACE>
        SET PC, tokenizeln_sp
    IFE A, 0x0022       ; "
        SET PC, tokenizeln_quot
    IFG A, 0x0040       ; "A"-1
        IFL A, 0x005B   ; "Z"+1
            SET PC, tokenizeln_letter
    ; check for OPERATOR tokens
    SET X, tokens_op
    JSR check_tokens
    IFE A, 0x1010       ; REM
        SET PC, tokenizeln_rem
    IFN A, 0
        SET PC, tokenizeln_tok
:tokenizeln_sym
    IFN [NEXTFLG], 0
        IFE [Z], 0x002c ; ","
            SET PC, tokenizeln_toknext
    IFE [Z], 0x003a     ; ":"
        SET [NEXTFLG], 0
    SET [Y], [Z]
    ADD Y, 1
:tokenizeln_sp
    ADD Z, 1
    SET PC, tokenizeln_any

:tokenizeln_toknext
    SET [Y], 0x003a     ; :
    ADD Y, 1
    SET [Y], 0x1002     ; NEXT
    ADD Y, 1
    ADD Z, 1
    SET PC, tokenizeln_any

:tokenizeln_letter
    ; check for ALL tokens
    SET X, tokens
    JSR check_tokens
    IFE A, 0x1003       ; DATA
        SET PC, tokenizeln_rawst
    IFE A, 0x1002       ; NEXT
        SET PC, tokenizeln_nextst
    IFE A, 0x1010       ; REM
        SET PC, tokenizeln_rem
    IFE A, 0
        SET PC, tokenizeln_sym
:tokenizeln_tok
    SET [Y], A
    ADD Y, 1
    ADD Z, B
    SET PC, tokenizeln_any

:tokenizeln_rem
    SET [Y], A
    ADD Y, 1
    ADD Z, B
:tokenizeln_rem_loop
    SET A, [Z]
    IFE A, 0x00FF       ; end
        SET PC, tokenizeln_end
    SET [Y], A
    ADD Y, 1
    ADD Z, 1
    SET PC, tokenizeln_rem_loop

:tokenizeln_rawst
    SET [Y], A
    ADD Y, 1
    ADD Z, 4            ; "DATA"
    JSR skipspc
:tokenizeln_rawst_loop
    SET A, [Z]
    IFE A, 0x003A       ; :
        SET PC, tokenizeln_any
    IFE A, 0x00FF       ; end
        SET PC, tokenizeln_end
    SET [Y], A
    ADD Y, 1
    ADD Z, 1
    SET PC, tokenizeln_rawst_loop

:tokenizeln_nextst
    SET [NEXTFLG], 1
    SET [Y], A
    ADD Y, 1
    ADD Z, B
    SET PC, tokenizeln_any

:tokenizeln_quot
    SET [Y], A
    ADD Y, 1
    ADD Z, 1
:tokenizeln_quot_loop
    SET A, [Z]
    IFE A, 0x0022       ; "
        SET PC, tokenizeln_quot_end
    IFE A, 0x00FF       ; end
        SET PC, tokenizeln_end
    SET [Y], A
    ADD Y, 1
    ADD Z, 1
    SET PC, tokenizeln_quot_loop

:tokenizeln_quot_end
    SET [Y], A
    ADD Y, 1
    ADD Z, 1
    SET PC, tokenizeln_any

:tokenizeln_end
    SET [Y], 0xFFFF
    ADD Y, 1
    SET A, Y
    SUB A, STR2
    SET [STR2LEN], A
    SET PC, POP

; ===========================
; INTERPRETER
; ===========================

; Run the entire program
:runprog
    SET [LOOPSP], EXPR_STACK
    SET [JUMPING], 0
    SET [DIRECTFLG], 0
    SET [DATAPTR], [PMEMSPTR]
    SET [DATASTMT], 0
    SET [NOARRAY], 0

    SET Z, [PMEMSPTR]
    SET [EXECPTR], Z
    JSR BASIC_CLR_RAW
    SET [BREAKFLG], 0
    SET [RUNNING], 0xFFFF
    JSR runprog_skip_lines
:runprog_loop
    IFG Z, [PMEMFPTR]
        SET PC, runprog_end
    IFE Z, [PMEMFPTR]
        SET PC, runprog_end
    IFN [BREAKFLG], 0       ; BREAK?
        SET PC, runprog_end ; if so, back to interpreter
    SET [CURLINE], [Z]
    ADD Z, 2
    JSR executeln
    IFN [JUMPING], 0
        SET PC, runprog_assign
    SET [EXECPTR], Z
    SET PC, runprog_loop
:runprog_assign
    SET [JUMPING], 0
    SET Z, [EXECPTR]
    SET PC, runprog_loop
:runprog_end
    SET [RUNNING], 0
    SET [readyflag], 1
    SET PC, POP

:runprog_skip_lines
    IFE Z, [PMEMFPTR]
        SET PC, POP
    IFL [RESULTLN], [Z]
        SET PC, POP
    IFE [RESULTLN], [Z]
        SET PC, POP
    ADD Z, [Z+1]
    ADD Z, 2
    SET PC, runprog_skip_lines

; Dump tokenized line at Z as hex
; Ends when finds 0xFFFF, [Z] goes beyond 0xFFFF
:dumpln
    JSR skipspc
    SET A, 0x0058       ; "X"
    JSR chrout
    SET A, Z
    JSR hexout
    SET A, 0x0011       ; <ENTER>
    JSR chrout
; dump @ Z
:dumpln_dump
    SET A, [Z]
    IFE A, 0xFFFF
        SET PC, dumpln_dump_end
    JSR hexout
    ADD Z, 1
    SET A, 0x0020       ; <SPACE>
    JSR chrout
    SET PC, dumpln_dump
:dumpln_dump_end
    ADD Z, 1
    SET A, 0x0011       ; <ENTER>
    JSR chrout
    SET PC, POP

:breakkey
    SET PUSH, A
    SET PUSH, B
    SET PUSH, C
    SET A, 2
    SET B, 0x13             ; <DEL>
    HWI [DEVKEYB]
    IFE C, 0
        SET PC, breakkey_no
    ; BREAK message
:breakkey_msg
    SET A, 0
    HWI [DEVKEYB]
    SET [EXECPTR], Z
    IFN [DIRECTFLG], 0
        SET PC, breakkey_dmode
    IFN [RUNNING], 0
        SET [RUNNING], 1
    SET [BREAKFLG], 0xFFFF
    SET I, msg_breakln
    JSR txtout
    SET A, [CURLINE]
    SET B, 0
    JSR int_str
    SET I, STR3
    JSR txtout
    SET A, 0x11
    JSR chrout
    SET C, POP
    SET B, POP
    SET A, POP
    SET [readyflag], 1
    JSR repl_loop
    SET PC, POP
:breakkey_no
    SET C, POP
    SET B, POP
    SET A, POP
    SET PC, POP

:breakkey_dmode
    SET I, msg_break
    JSR txtout
    SET [BREAKFLG], 0xFFFF
    SET [RUNNING], 0
    SET [readyflag], 1
    SET PC, repl_loop

:breakkey_raw
    SET PUSH, B
    SET PUSH, C
    SET A, 2
    SET B, 0x13             ; <DEL>
    HWI [DEVKEYB]
    SET A, 1
    IFN C, 0
        SET PC, breakkey_raw_yes
    SET A, 0
:breakkey_raw_yes
    SET C, POP
    SET B, POP
    SET PC, POP

; Execute tokenized line at Z
; Ends when finds 0xFFFF, [Z] goes beyond 0xFFFF
:executeln
    JSR skipspc             ; skip spaces
    JSR breakkey            ; Test break key
    IFN [BREAKFLG], 0       ; BREAK?
        SET PC, POP         ; stop execution
    IFE [Z], 0xFFFF         ; end of statement
        SET PC, executeln_end
    IFG [Z], 0x1FFF         ; non-primary tokens are invalid as initials
        SET PC, error_syntax  
    IFG [Z], 0x0FFF         ; primary token
        SET PC, executeln_stmt
    ; It must be a variable then?
:executeln_check_var
    IFG [Z], 0x0040         ; "A"-1
        IFL [Z], 0x005a     ; "Z"+1
            SET PC, executeln_var
    IFE [Z], 0x005F         ; "_"
        SET PC, executeln_var
    IFE [Z], 0x003a         ; ":"
        SET PC, executeln_skip
    SET PC, error_syntax    ; anything else is invalid

:executeln_skip
    ADD Z, 1
    SET PC, executeln

:executeln_end
    ADD Z, 1
    SET PC, POP

:executeln_stmt             ; Execute statement
    SET A, [Z]
    AND A, 0x0FFF
    ADD Z, 1
    JSR [A+stmt_table]
    SET PC, executeln

:executeln_var              ; Go over entire variable
    JSR exec_var
    IFE [VARTYPE], 0
        SET PC, error_syntax
    JSR skipspc
    IFN [Z], 0x4010         ; '='
        SET PC, error_syntax
    ADD Z, 1
    JSR skipspc
    ; save var data
    SET C, 17
    SET I, VARTYPE
    SET J, VARBACKUP
    JSR fast_copy_block_f
    JSR exec_expr
    ; restore var data
    SET C, 17
    SET I, VARBACKUP
    SET J, VARTYPE
    JSR fast_copy_block_f
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    JSR VAR_SET
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    SET PC, executeln

; Find next DATA statement, or raise error
:data_next
    SET [RUNLINE], Z
    SET Z, [DATAPTR]
    IFE Z, [PMEMSPTR]
        ADD Z, 2            ; initial statement
:data_next_stmt
    JSR skipspc
    IFE Z, [PMEMFPTR]
        SET PC, data_next_err
    IFG Z, [PMEMFPTR]
        SET PC, data_next_err
    IFE [Z], 0xFFFF
        SET PC, data_next_nl; next line
    IFE [Z], 0x1003         ; DATA
        SET PC, data_next_found
    IFN [DATASTMT], 0
        IFE [Z], 0x002c     ; comma
            SET PC, data_next_found
    JSR exec_endst
    IFN A, 0
        SET PC, data_next_endstmt
    IFN [DATASTMT], 0
        SET PC, error_syntax
:data_next_skip_loop
    ADD Z, 1
    JSR exec_endst
    IFN A, 0
        SET PC, data_next_skip_loop
    SET PC, data_next_endstmt

:data_next_found
    ADD Z, 1
    JSR skipspc
    SET [DATAPTR], Z
    SET [DATASTMT], 1
    SET Z, [RUNLINE]
    SET PC, POP
:data_next_err
    SET [DATASTMT], 0
    SET Z, [RUNLINE]
    SET A, 4
    SET PC, error_fatal_curln

:data_next_endstmt
    ADD Z, 1                ;>FFFF LnNm LLen ...
                            ; FFFF LnNm LLen>... 
    SET [DATASTMT], 0
    SET PC, data_next_stmt

:data_next_nl
    ADD Z, 3                ;>FFFF LnNm LLen ...
                            ; FFFF LnNm LLen>... 
    SET [DATASTMT], 0
    SET PC, data_next_stmt

; Memory bank switching
; switch_code is the default state.
; IF SWITCHED AWAY FROM switch_code, MUST SWITCH BACK ONCE COMPLETE.
:switch_code                ; Switch to code memory
    SET A, 1
    ; Switch 0x7000-0xefff
    SET B, 0b0000000000000000
    HWI [DEVMEM]
    SET PC, POP

:switch_vars                ; Switch to variable memory
    JSR rnd_inc
    SET A, 1
    ; Switch 0x7000-0xefff
    SET B, 0b0111111110000000
    HWI [DEVMEM]
    SET PC, POP

:exec_endst                 ; A = 1 if end of statement
                            ; A = 0 if not
                            ; (checks at [Z])
    JSR skipspc
    SET A, 1
    IFE [Z], 0xFFFF         ; end of line
        SET PC, POP
    IFE [Z], 0x1010         ; REM
        SET PC, POP
    IFE [Z], 0x003A         ; :
        SET PC, POP
    SET A, 0
    SET PC, POP

:exec_enddata               ; A = 1 if end of DATA entry
                            ; A = 0 if not
                            ; (checks at [Z])
    JSR skipspc
    SET A, 1
    IFE [Z], 0xFFFF         ; end of line
        SET PC, POP
    IFN [BTMP], 0
        SET PC, exec_enddata_match
    IFE [Z], 0x1010         ; REM
        SET PC, POP
    IFE [Z], 0x003A         ; :
        SET PC, POP
    IFE [Z], 0x002C         ; ,
        SET PC, POP
:exec_enddata_match
    SET A, 0
    SET PC, POP

; Parse non-negative (>=0) 48-bit(!) INT from [Z]
:exec_nnint                 ; A = 1 if successfully parsed
                            ; A = 0 if not
                            ; [BTMP+0] hi, [BTMP+1] med, [BTMP+2] lo
    JSR skipspc
    SET I, Z
    SET J, BTMP
    JSR str_int48
    SET A, 0
    IFE I, Z
        SET PC, POP
    SET A, 1
    SET Z, I
    SET PC, POP

:exec_expr_err
    SET A, [EXPRERR]
    SET PC, error_fatal_curln

:exec_expr_nostk
    SET A, 15
    SET PC, error_fatal_curln

; Parse an expression at Z
; return a value in EXPR_STACK
:exec_expr
    JSR skipspc
    JSR exec_endst
    IFN A, 0
        SET [EXPRERR], 2
    IFN A, 0
        SET PC, POP
    SET [EXPRERR], 0
    SET [EXPRSP], SYS_STACK     ; end of EXPR_STACK
:exec_expr_raw
:exec_expr_xor
    JSR skipspc
    JSR exec_expr_or
    JSR skipspc
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
:exec_expr_xor_chain
    IFN [Z], 0x4006             ; XOR
        SET PC, POP
    ADD Z, 1
    JSR exec_expr_or
    JSR skipspc
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    JSR OP_XOR
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    SET PC, exec_expr_xor_chain

:exec_expr_or
    JSR skipspc
    JSR exec_expr_and
    JSR skipspc
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
:exec_expr_or_chain
    IFN [Z], 0x4007             ; OR
        SET PC, POP
    ADD Z, 1
    JSR exec_expr_and
    JSR skipspc
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    JSR OP_OR
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    SET PC, exec_expr_or_chain

:exec_expr_and
    JSR skipspc
    JSR exec_expr_not
    JSR skipspc
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
:exec_expr_and_chain
    IFN [Z], 0x4005             ; AND
        SET PC, POP
    ADD Z, 1
    JSR exec_expr_not
    JSR skipspc
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    JSR OP_AND
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    SET PC, exec_expr_and_chain

:exec_expr_not
    IFL SP, SYS_STACK_LM        ; "too complex" check
        SET PC, exec_expr_nostk
    IFE [Z], 0x2006             ; NOT
        SET PC, exec_expr_not_op
    SET PC, exec_expr_compar

:exec_expr_not_op
    ADD Z, 1
    JSR exec_expr_not
    SET PC, OP_NOT

:exec_expr_compar
    JSR skipspc
    JSR exec_expr_addsub
    JSR skipspc
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
:exec_expr_compar_chain
    IFL [Z], 0x400c
        SET PC, POP
    IFG [Z], 0x4011
        SET PC, POP
    SET PUSH, [Z]
    ADD Z, 1
    JSR exec_expr_addsub
    JSR skipspc
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    SET A, POP
    SUB A, 0x400c
    JSR [A+OP_COMPAR]
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    SET PC, exec_expr_compar_chain

:OP_COMPAR
    DAT OP_GE
    DAT OP_NE
    DAT OP_LE
    DAT OP_GT
    DAT OP_EQ
    DAT OP_LT

:exec_expr_addsub_minus
    XOR A, 0xFFFF
:exec_expr_addsub_plus
    ADD Z, 1
    JSR skipspc
    SET PC, exec_expr_addsub_pre

:exec_expr_addsub_chain_minus
    XOR A, 0xFFFF
:exec_expr_addsub_chain_plus
    ADD Z, 1
    JSR skipspc
    SET PC, exec_expr_addsub_chain_pre

:exec_expr_addsub
    JSR skipspc
    SET A, 0
:exec_expr_addsub_pre
    IFE [Z], 0x4000             ; +
        SET PC, exec_expr_addsub_plus
    IFE [Z], 0x4001             ; -
        SET PC, exec_expr_addsub_minus
    SET PUSH, A
    JSR exec_expr_imod
    IFN 0, POP
        JSR OP_NEG
    JSR skipspc
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
:exec_expr_addsub_chain
    IFN [Z], 0x4000             ; +
        IFN [Z], 0x4001         ; -
            SET PC, POP
    SET PUSH, [Z]
    ADD Z, 1
    SET A, 0
:exec_expr_addsub_chain_pre
    IFE [Z], 0x4000             ; +
        SET PC, exec_expr_addsub_chain_plus
    IFE [Z], 0x4001             ; -
        SET PC, exec_expr_addsub_chain_minus
    SET PUSH, A
    JSR exec_expr_imod
    IFN 0, POP
        JSR OP_NEG
    JSR skipspc
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    SET A, POP
    SUB A, 0x4000
    JSR [A+OP_ADDSUB]
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    SET PC, exec_expr_addsub_chain

:OP_ADDSUB
    DAT OP_ADD
    DAT OP_SUB

:exec_expr_imod
    JSR skipspc
    JSR exec_expr_idiv
    JSR skipspc
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
:exec_expr_imod_chain
    IFN [Z], 0x4009             ; MOD
        SET PC, POP
    ADD Z, 1
    JSR exec_expr_idiv
    JSR skipspc
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    JSR OP_IMOD
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    SET PC, exec_expr_imod_chain

:exec_expr_idiv
    JSR skipspc
    JSR exec_expr_muldiv
    JSR skipspc
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
:exec_expr_idiv_chain
    IFN [Z], 0x4008             ; DIV
        SET PC, POP
    ADD Z, 1
    JSR exec_expr_muldiv
    JSR skipspc
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    JSR OP_IDIV
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    SET PC, exec_expr_idiv_chain

:exec_expr_muldiv
    JSR skipspc
    JSR exec_expr_pow
    JSR skipspc
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
:exec_expr_muldiv_chain
    IFN [Z], 0x4002             ; *
        IFN [Z], 0x4003         ; /
            SET PC, POP
    SET PUSH, [Z]
    ADD Z, 1
    JSR exec_expr_pow
    JSR skipspc
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    SET A, POP
    SUB A, 0x4002
    JSR [A+OP_MULDIV]
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    SET PC, exec_expr_muldiv_chain

:OP_MULDIV
    DAT OP_MUL
    DAT OP_DIV

:exec_expr_pow
    JSR skipspc
    JSR exec_expr_unary
    JSR skipspc
    SET PUSH, 0
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
:exec_expr_pow_chain
    IFN [Z], 0x4004             ; ^
        SET PC, exec_expr_pow_end
    ADD Z, 1
    JSR exec_expr_unary
    JSR skipspc
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    ADD PEEK, 1
    SET PC, exec_expr_pow_chain

:exec_expr_pow_end
    IFE PEEK, 0
        SET PC, exec_expr_pow_ret
    JSR OP_POW
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    SUB PEEK, 1
    SET PC, exec_expr_pow_end
:exec_expr_pow_ret
    SET 0, POP
    SET PC, POP

:exec_expr_syntax
    SET [EXPRERR], 2
    SET PC, POP
:exec_expr_illegalarg
    SET [EXPRERR], 5
    SET PC, POP
:exec_expr_typemis
    SET [EXPRERR], 13
    SET PC, POP

:exec_expr_unary
    SET A, 0
    SET PC, exec_expr_unary_raw
:exec_expr_unary_not
    XOR A, 2
    ADD Z, 1
    SET PC, exec_expr_unary_raw
:exec_expr_unary_neg
    XOR A, 1
:exec_expr_unary_pos
    ADD Z, 1
:exec_expr_unary_raw
    IFE [Z], 0x2006             ; NOT
        SET PC, exec_expr_unary_not
    IFE [Z], 0x4000             ; +
        SET PC, exec_expr_unary_pos
    IFE [Z], 0x4001             ; -
        SET PC, exec_expr_unary_neg
    SET PUSH, A
    JSR exec_expr_val
    SET A, POP
    IFB A, 2
        JSR OP_NOT
    IFB A, 1
        JSR OP_NEG
    SET PC, POP

:exec_expr_val
    JSR exec_endst
    IFN A, 0
        SET PC, exec_expr_syntax
    IFG [Z], 0x2FFF             ; 0x3000 - 1
        IFL [Z], 0x4000         ; 0x3FFF + 1
            SET PC, exec_expr_val_func
    IFE [Z], 0x0028             ; (
        SET PC, exec_expr_val_pare
    IFE [Z], 0x0025             ; %
        SET PC, exec_expr_val_bin
    IFE [Z], 0x0026             ; &
        SET PC, exec_expr_val_hex
    IFE [Z], 0x2003             ; FN
        SET PC, exec_expr_val_stmt_fn
    IFE [Z], 0x0022             ; "
        SET PC, exec_expr_val_str
    IFE [Z], 0x002e             ; .
        SET PC, exec_expr_val_num
    IFG [Z], 0x002f             ; '0'-1
        IFL [Z], 0x003a         ; '9'+1
            SET PC, exec_expr_val_num
    IFE [Z], 0x005f             ; '_'
        SET PC, exec_expr_var
    IFL [Z], 0x0041             ; 'A'
        SET PC, exec_expr_syntax
    IFG [Z], 0x005a             ; 'Z'
        SET PC, exec_expr_syntax
:exec_expr_var
    JSR exec_var
    IFE [VARTYPE], 0
        SET PC, exec_expr_syntax
    JSR VAR_GET
    SET PC, POP

:exec_expr_val_func
    ; call respective function
    SET A, [Z]
    AND A, 0xFF
    ADD Z, 1
    JSR skipspc
    JSR [A+func_table]
    IFL [EXPRSP], EXPR_STACK_LM
        SET PC, exec_expr_nostk
    SET PC, POP

:exec_expr_val_stmt_fn
    IFL SP, SYS_STACK_LM        ; "too complex" check
        SET PC, exec_expr_nostk
    ADD Z, 1
    SET [NOARRAY], 1
    JSR exec_var
    IFN [VARTYPE], 0x0011       ; proper name?
        SET PC, exec_expr_syntax
    SET [BTMP+2], [VARLEN]
    SUB SP, 15
    SET I, VARNAME
    SET J, SP
    SET C, 15
    JSR fast_copy_block_f       ; save VARNAME before exec_expr
    JSR skipspc
    IFN [Z], 0x0028             ; (
        SET PC, exec_expr_syntax
    ADD Z, 1
    JSR exec_expr_raw
    SET X, [EXPRSP]
    IFE [X], 3
        SET PC, exec_expr_typemis
    JSR FP0_loadx
    JSR FP0_store
    JSR skipspc
    IFN [Z], 0x0029             ; )
        SET PC, exec_expr_syntax
    ADD Z, 1
    SET [VARTYPE], 0x0030
    SET [VARLEN], [BTMP+2]
    SET I, SP
    SET J, VARNAME
    SET C, 15
    JSR fast_copy_block_f       ; restore VARNAME from exec_expr
    ADD SP, 15
    JSR VAR_GET
    IFE Y, 0                    ; no such function
        SET PC, exec_expr_val_stmt_fn_no
    JSR switch_vars
    SET [BTMP+0], [Y+0]
    SET [BTMP+1], [Y+1]
    SET [VARTYPE], 0x0011
    SET [VARLEN], [Y+2]
    SET I, Y
    ADD I, 3
    SET J, VARNAME
    SET C, [VARLEN]
:exec_expr_val_stmt_fn_copy
    STI [J], [I]
    SUB C, 1
    IFG C, 0
        SET PC, exec_expr_val_stmt_fn_copy
    JSR VAR_GET
    
    SET PUSH, Z
    SET PUSH, [CURLINE]

    ; move float from expr stack to main stack
    SET X, [EXPRSP]
    SET PUSH, [X+5]
    SET PUSH, [X+4]
    SET PUSH, [X+3]
    SET PUSH, [X+2]
    SET PUSH, [X+1]
    SET PUSH, [X]
    ADD [EXPRSP], 6

    JSR VAR_SET
    ; switch_code is done by VAR_SET
    SET Z, [BTMP]
    SET [CURLINE], [BTMP+1]
    JSR VARDATA_TO_STK
    IFL SP, SYS_STACK_LM        ; "too complex" check
        SET PC, exec_expr_nostk
    JSR exec_expr_raw
    JSR VARDATA_FROM_STK

    ; restore old value
    ; move float from main stack to expr stack
    SUB [EXPRSP], 6
    SET X, [EXPRSP]
    SET [X], POP
    SET [X+1], POP
    SET [X+2], POP
    SET [X+3], POP
    SET [X+4], POP
    SET [X+5], POP

    JSR VAR_SET
    JSR skipspc
    JSR exec_endst
    IFE A, 0                    ; must be end of statement afterwards
        SET PC, exec_expr_syntax
    SET [CURLINE], POP
    SET Z, POP
    SET PC, POP

:exec_expr_val_stmt_fn_no
    SET A, 17
    SET PC, error_fatal_curln

:exec_expr_val_pare
    ADD Z, 1
    JSR skipspc
    JSR exec_expr_raw
    IFN [EXPRERR], 0
        SET PC, POP
    JSR skipspc
    IFN [Z], 0x0029             ; )
        SET PC, exec_expr_syntax
    ADD Z, 1
    SET PC, POP

:exec_expr_val_bin
    SET [BTMP], 0
    SET [BTMP+1], 0
:exec_expr_val_bin_loop
    ADD Z, 1
    IFN [Z], 0x0030             ; "0"
        IFN [Z], 0x0031         ; "1"
            SET PC, exec_expr_val_bin_end
    SHL [BTMP], 1
    ROL [BTMP+1], 1
    IFE [Z], 0x0031
        BOR [BTMP], 1
    SET PC, exec_expr_val_bin_loop
:exec_expr_val_bin_end
    SET I, [EXPRSP]
    SET [I], 1 ; int
    SET [I+1], [BTMP]
    SET [I+2], [BTMP+1]
    SET PC, POP

:exec_expr_val_hex
    SET [BTMP], 0
    SET [BTMP+1], 0
:exec_expr_val_hex_loop
    ADD Z, 1
    IFG [Z], 0x002F             ; "0"-1
        IFL [Z], 0x003A         ; "9"+1
            SET PC, exec_expr_val_hex_ok
    IFG [Z], 0x0040             ; "A"-1
        IFL [Z], 0x0047         ; "F"+1
            SET PC, exec_expr_val_hex_ok
    SET PC, exec_expr_val_hex_end
:exec_expr_val_hex_ok
    SHL [BTMP], 4
    ROL [BTMP+1], 4
    SET A, [Z]
    SUB A, 0x0030
    IFG A, 0x0010
        SUB A, 7
    ADD [BTMP], A
    SET PC, exec_expr_val_hex_loop
:exec_expr_val_hex_end
    SET I, [EXPRSP]
    SET [I], 1 ; int
    SET [I+1], [BTMP]
    SET [I+2], [BTMP+1]
    SET PC, POP

:exec_expr_val_num
    SET A, Z
    JSR str_num
    SET Z, I
    IFE A, 0xFFFE
        SET PC, exec_expr_val_num_fpe
    IFE A, 1
        SET PC, exec_expr_val_num_int
    IFE A, 2
        SET PC, exec_expr_val_num_fp

:exec_expr_val_num_int
    SUB [EXPRSP], 3
    IFL [EXPRSP], EXPR_STACK_LM
        SET PC, exec_expr_nostk
    SET I, [EXPRSP]
    SET [I], 1 ; int
    SET [I+1], [FTMP]
    SET [I+2], [FTMP+1]
    SET PC, POP

:exec_expr_val_num_fp
    SUB [EXPRSP], 6
    IFL [EXPRSP], EXPR_STACK_LM
        SET PC, exec_expr_nostk
    SET I, [EXPRSP]
    SET [I], 2 ; float
    SET [I+1], [FP0]
    SET [I+2], [FP0+1]
    SET [I+3], [FP0+2]
    SET [I+4], [FP0+3]
    SET [I+5], [FP0+4]
    SET PC, POP

:exec_expr_val_num_fpe
    SET A, [FPERROR]
    SET A, [A+err_table]
    SET [EXPRERR], A
    SET [FPERROR], 0
    SET PC, POP

:exec_expr_val_str
    SET I, Z
:exec_expr_val_str_loop
    ADD I, 1
    IFE [I], 0x0022             ; "
        SET PC, exec_expr_val_str_end
    IFB [I], 0xFF00             ; not valid
        SET PC, exec_expr_val_str_end
    SET PC, exec_expr_val_str_loop
:exec_expr_val_str_end
    SET A, I
    SUB A, Z
    SUB A, 1
    SUB [EXPRSP], 2
    SUB [EXPRSP], A
    SET I, [EXPRSP]
    SET [I], 3 ; string
    SET [I+1], A
    ADD I, 2
    ADD Z, 1
:exec_expr_val_str_copy
    IFE A, 0
        SET PC, exec_expr_val_str_done
    STI [I], [Z]
    ADD Z, 1
    SUB A, 1
    SET PC, exec_expr_val_str_copy
:exec_expr_val_str_done
    IFE [Z], 0x0022
        ADD Z, 1
    SET PC, POP

; Scan at [Z] to VARLEN, VARTYPE and VARNAME
; if VARTYPE is 0, invalid
:exec_var
    JSR skipspc
    SET [VARLEN], 0x0000 
    SET [VARTYPE], 0x0000       
    SET A, 0
    IFL [Z], 0x0041         ; A
        SET PC, exec_var_end
    IFN [Z], 0x005f         ; _
        IFG [Z], 0x005A     ; Z
            SET PC, exec_var_end
    SET [VARNAME], [Z]
    SET A, 1
    ADD Z, 1
:exec_var_scan
    IFG [Z], 0x002f             ; '0'-1
        IFL [Z], 0x003a         ; '9'+1
            SET PC, exec_var_scan_ok
    IFL [Z], 0x0041         ; A
        SET PC, exec_var_end
    IFN [Z], 0x005f             ; _
        IFG [Z], 0x005A         ; Z
            SET PC, exec_var_end
:exec_var_scan_ok                
    IFL A, 15
        SET [A+VARNAME], [Z]              
    IFL A, 15
        ADD A, 1
    ADD Z, 1
    SET PC, exec_var_scan
:exec_var_end
    IFE A, 0
        SET PC, POP
    SET [VARLEN], A
    SET [VARTYPE], 0x0011
    JSR skipspc
    SET A, [Z]
    IFE A, 0x0023               ; #
        SET PC, POP
    IFE A, 0x0024               ; $
        SET PC, exec_var_t_str
    IFE A, 0x0025               ; %
        SET PC, exec_var_t_int
    IFN [NOARRAY], 0
        SET PC, exec_var_noarr
    IFE A, 0x0028               ; (
        SET PC, exec_var_array
    SET PC, POP
:exec_var_t_str
    SET [VARTYPE], 0x0012
    ADD Z, 1
    JSR skipspc
    IFE [Z], 0x0028             ; (
        SET PC, exec_var_array
    SET PC, POP
:exec_var_t_int
    SET [VARTYPE], 0x0010
    ADD Z, 1
    JSR skipspc
    IFE [Z], 0x0028             ; (
        SET PC, exec_var_array
    SET PC, POP

:exec_var_noarr
    SET [NOARRAY], 0
    SET PC, POP

; STR3+255 = array dimension counter
; STR3+256 = array dimension indeces
:exec_var_array
    ADD Z, 1
    ADD [VARTYPE], 0x0010       ; turn to array type
    IFE [Z], 0x0029             ; )
        SET PC, error_syntax
    JSR exec_endst
    IFN A, 0
        SET PC, error_syntax
    SET [STR3+255], 0           ; STR3+255: array dimension counter
:exec_var_array_impr
    JSR skipspc
    JSR VARDATA_TO_STK
    IFL SP, SYS_STACK_LM        ; "too complex" check
        SET PC, exec_expr_nostk
    JSR exec_expr
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    JSR VARDATA_FROM_STK
    SET X, [EXPRSP]
    IFN [X], 1
        SET PC, error_typemis
    IFN [X+2], 0
        SET PC, error_illegalarg
    SET A, [STR3+255]
    ADD A, 256
    SET [STR3+A], [X+1]
    ADD [EXPRSP], 3
    ADD [STR3+255], 1
    JSR skipspc
    IFE [Z], 0x002c             ; ","
        SET PC, exec_var_array_comma
    IFE [Z], 0x0029             ; ")"
        SET PC, exec_var_array_end
    SET PC, error_syntax
:exec_var_array_end
    ADD Z, 1
    SET PC, POP

:exec_var_array_comma
    ADD Z, 1
    SET PC, exec_var_array_impr

; Display error message A (line CURLINE), end program
:error_fatal_curln
    SET B, [CURLINE]
; Display error message A (line B), end program
:error_fatal_ln
    IFN [DIRECTFLG], 0  ; no line number ever if direct mode
        SET PC, error_fatal
    SET PUSH, A
    SET PUSH, B
    SET PUSH, A
    SET I, msg_error
    JSR txtout
    SET A, POP
    SET B, 0
    JSR int_str
    SET I, STR3
    JSR txtout
    SET I, msg_error_at
    JSR txtout
    SET B, POP
    SET A, B
    SET B, 0
    JSR int_str
    SET I, STR3
    JSR txtout
    SET A, 0x0020       ; <Space>
    JSR chrout
    SET A, POP
    SET I, [A+errmsgs]
    JSR txtout
    SET A, 0x0011       ; <Enter>
    JSR chrout
    SET PC, BASIC_CLR

; Display error message A, end program
:error_fatal
    SET PUSH, A
    SET PUSH, A
    SET I, msg_error
    JSR txtout
    SET A, POP
    SET B, 0
    JSR int_str
    SET I, STR3
    JSR txtout
    SET A, 0x0020       ; <Space>
    JSR chrout
    SET A, POP
    SET I, [A+errmsgs]
    JSR txtout
    SET A, 0x0011       ; <Enter>
    JSR chrout
    SET PC, BASIC_CLR

:error_mem
    SET A, 7
    SET PC, error_fatal
:error_syntax
    SET A, 2
    SET PC, error_fatal_curln
:error_direct
    SET A, 12
    SET PC, error_fatal_curln
:error_illegalarg
    SET A, 5
    SET PC, error_fatal_curln
:error_noln
    SET A, 8
    SET PC, error_fatal_curln
:error_typemis
    SET A, 13
    SET PC, error_fatal_curln
:error_strlen
    SET A, 14
    SET PC, error_fatal_curln
:error_cplx
    SET A, 15
    SET PC, error_fatal_curln

:error_fp
    SET A, [FPERROR]
    SET [FPERROR], 0
    SET A, [A+err_table]
    SET PC, error_fatal_curln

:BASIC_NEW
    JSR BASIC_NEW_RAW
:BASIC_CLR
    SET [readyflag], 1
    SET SP, 0x0000
    SET PC, repl_loop
:BASIC_CLR_RAW
    JSR switch_code
    SET [RUNNING], 0
    SET [VMEMSPTR], PROG_DATA
    SET [VMEMFPTR], PROG_DATA
    SET [VMEMEND], 0xF000
    SET I, 0
:BASIC_CLR_RAW_LIST
    STI [I+VARLIST], 0
    IFL I, 27
        SET PC, BASIC_CLR_RAW_LIST
    SET PC, POP

:BASIC_NEW_RAW
    JSR BASIC_CLR_RAW
    SET [PMEMSPTR], PROG_DATA
    SET [PMEMFPTR], PROG_DATA
    SET [PMEMEND], 0xF000
    SET PC, POP

; Program between lines B and C (inclusive)
:prog_listing
    SET [readyflag], 1
    SET I, [PMEMSPTR]
:prog_listing_loop
    IFE I, [PMEMFPTR]
        SET PC, POP
    IFL [I], B
        SET PC, prog_listing_skip
    IFG [I], C
        SET PC, POP
    JSR breakkey_raw
    IFN A, 0
        SET PC, prog_listing_break
    JSR prog_listing_line
:prog_listing_skip
    ADD I, [I+1]
    ADD I, 2
    SET PC, prog_listing_loop

:prog_listing_break
    SET I, msg_breaklist
    JSR txtout
    SET PC, POP

; List program line at I to out
:prog_listing_line
    SET PUSH, B
    SET PUSH, I
    SET A, [I]
    SET B, 0
    JSR int_str
    SET I, STR3
    JSR txtout
    SET A, 0x0020   ; <SPACE>
    JSR chrout
    SET I, POP
    SET B, POP
    SET J, I
    ADD J, 2
:prog_listing_line_chr
    IFE [J], 0xFFFF
        SET PC, prog_listing_line_end
    IFG [J], 0x2FFF ; 0x3000-1
        SET PC, prog_listing_token
    IFG [J], 0x0FFF ; 0x1000-1
        SET PC, prog_listing_token_sp
    SET A, [J]
    SET PUSH, J
    JSR chrout
    SET J, POP
    ADD J, 1
    SET PC, prog_listing_line_chr
:prog_listing_line_end
    SET A, 0x0011   ; <ENTER>
    JSR chrout
    ADD J, 1
    SET PC, POP

:prog_listing_token
    SET A, [J]
    JSR prog_listing_print_token
    ADD J, 1
    SET PC, prog_listing_line_chr

:prog_listing_token_sp
    SET A, [J]
    IFE A, 0x2000   ; TAB
        JSR prog_listing_token_printsp
    IFE A, 0x2001   ; ELSE
        JSR prog_listing_token_printsp
    IFE A, 0x2002   ; TO
        JSR prog_listing_token_printsp
    IFE A, 0x2004   ; SPC
        JSR prog_listing_token_printsp
    IFE A, 0x2005   ; THEN
        JSR prog_listing_token_printsp
    IFE A, 0x2007   ; STEP
        JSR prog_listing_token_printsp
    IFE A, 0x2008   ; UNTIL
        JSR prog_listing_token_printsp
    IFE A, 0x2009   ; WHILE
        JSR prog_listing_token_printsp
    IFE A, 0x200A   ; OFF
        JSR prog_listing_token_printsp
    JSR prog_listing_print_token
    SET PUSH, J
    SET A, 0x0020   ; <SPACE>
    JSR chrout
    SET J, POP
    ADD J, 1
    SET PC, prog_listing_line_chr

:prog_listing_token_printsp
    SET PUSH, A
    SET PUSH, J
    SET A, 0x0020   ; <SPACE>
    JSR chrout
    SET J, POP
    SET A, POP
    SET PC, POP

:prog_listing_print_token
    SET PUSH, I
    SET I, tokens
:prog_listing_print_token_find
    IFE A, [I]
        SET PC, prog_listing_print_token_end
    IFE 0x0000, [I]
        SET PC, prog_listing_print_token_end_skip
    ADD I, [I+1]
    ADD I, 2
    SET PC, prog_listing_print_token_find
:prog_listing_print_token_end
    SET A, [I+1]
    ADD I, 2
    JSR txtnout
:prog_listing_print_token_end_skip
    SET I, POP
    SET PC, POP

; ===========================
; VARIABLES & ARRAYS
; ===========================
; Uses switch_code and switch_vars

:VAR_SLIST
    DAT 0
:VAR_LAST
    DAT 0
; find variable according to VARLEN, VARTYPE, VARNAME
; returns at X, X = 0 if not found
; if X =/= 0, Y contains access to variable data
; requires to be in variable memory mode (switch_vars)
:VAR_FIND
    SET [VAR_LAST], 0
    SET A, [VARNAME]
    SUB A, 0x0040   
    SET [VAR_SLIST], VARLIST
    ADD [VAR_SLIST], A
    SET X, [A+VARLIST]
    IFE [VARNAME], 0x005f   ; "_"
        SET X, [VARLIST]
    IFE [VARNAME], 0x005f   ; "_"
        SET [VAR_SLIST], VARLIST
:VAR_FIND_LOOP
    IFE X, 0
        SET PC, POP
    SET [VAR_LAST], X
    IFN [X], [VARTYPE]
        SET PC, VAR_FIND_LOOP_NM
    IFN [X+2], [VARLEN]
        SET PC, VAR_FIND_LOOP_NM
    SET C, [X+2]
    SET I, X
    ADD I, 3
    SET J, VARNAME
:VAR_FIND_SLOOP
    IFN [I], [J]
        SET PC, VAR_FIND_LOOP_NM
    STI 0, 0                ; increase I and J
    SUB C, 1
    IFG C, 0
        SET PC, VAR_FIND_SLOOP
    SET Y, I
    SET PC, POP
:VAR_FIND_LOOP_NM
    SET X, [X+1]
    SET PC, VAR_FIND_LOOP

; Calculate index based on STR3+255, STR3+256... and Y
; return in A
:VAR_CALCINDEX
    IFE [STR3+255], [Y]
        SET PC, VAR_CALCINDEX_VALID
:VAR_CALCINDEX_OVF
    SET [EXPRERR], 9        ; bad subscript
    SET PC, POP
:VAR_CALCINDEX_VALID   
    SET C, [Y]
    SET A, 0
    SET I, STR3
    ADD I, 256
:VAR_CALCINDEX_LOOP
    ADD Y, 1
    SET B, [Y]
    IFG [I], B
        SET PC, VAR_CALCINDEX_OVF
    ADD B, 1
    MUL A, B
    IFN EX, 0
        SET PC, VAR_CALCINDEX_OVF
    ADD A, [I]
    IFN EX, 0
        SET PC, VAR_CALCINDEX_OVF
    ADD I, 1
    SUB C, 1
    IFN C, 0
        SET PC, VAR_CALCINDEX_LOOP
    SET PC, POP

; Calculate length of array based on Y (ptr to array data)
:VAR_CALCLEN
    SET C, [Y]
    SET I, Y
    ADD I, 1
    SET A, [I]
    ADD A, 1
    SUB C, 1
    IFE C, 0
        SET PC, VAR_CALCLEN_END
:VAR_CALCLEN_LOOP
    ADD I, 1
    MUL A, [I]
    IFN EX, 0
        SET PC, error_mem
    SUB C, 1
    IFG C, 0
        SET PC, VAR_CALCLEN_LOOP
:VAR_CALCLEN_END
    SET PC, POP

:VAR_GET
    SET [ARRAYDIM], 0
    JSR switch_vars
    JSR VAR_FIND
    IFE X, 0
        SET PC, VAR_RDEF
:VAR_GET_RAW
    JSR switch_vars
    SET [ARRAYDIM], 0
    IFE [VARTYPE], 0x10     ; int
        SET PC, VAR_GET_INT
    IFE [VARTYPE], 0x11     ; float
        SET PC, VAR_GET_FLOAT
    IFE [VARTYPE], 0x12     ; str
        SET PC, VAR_GET_STR
    IFE [VARTYPE], 0x20     ; int
        SET PC, VAR_GET_ARRAY_INT
    IFE [VARTYPE], 0x21     ; float
        SET PC, VAR_GET_ARRAY_FLOAT
    IFE [VARTYPE], 0x22     ; str
        SET PC, VAR_GET_ARRAY_STR
    JSR switch_code
    SET PC, POP

; push default value based on VARTYPE
:VAR_RDEF
    IFE [VARTYPE], 0x10     ; int
        SET PC, VAR_RDEF_INT
    IFE [VARTYPE], 0x11     ; float
        SET PC, VAR_RDEF_FLOAT
    IFE [VARTYPE], 0x12     ; str
        SET PC, VAR_RDEF_STR
    IFE [VARTYPE], 0x20     ; int
        SET PC, VAR_RDEF_ARRAY_INT
    IFE [VARTYPE], 0x21     ; float
        SET PC, VAR_RDEF_ARRAY_FLOAT
    IFE [VARTYPE], 0x22     ; str
        SET PC, VAR_RDEF_ARRAY_STR
    JSR switch_code
    SET Y, 0
    SET PC, POP

:VAR_RDEF_INT
    SUB [EXPRSP], 3
    SET X, [EXPRSP]
    SET [X], 1              ; int
    SET [X+1], 0
    SET [X+2], 0
    SET PC, switch_code

:VAR_RDEF_FLOAT
    SUB [EXPRSP], 6
    SET X, [EXPRSP]
    SET [X], 2              ; float
    SET [X+1], 0
    SET [X+2], 0
    SET [X+3], 0
    SET [X+4], 0
    SET [X+5], 0
    SET PC, switch_code

:VAR_RDEF_STR
    SUB [EXPRSP], 2
    SET X, [EXPRSP]
    SET [X], 3              ; str
    SET [X+1], 0
    SET PC, switch_code

:VAR_RDEF_ARRAY_INT
:VAR_RDEF_ARRAY_FLOAT
:VAR_RDEF_ARRAY_STR
    JSR VAR_NEW
    SET PC, VAR_GET

:VAR_GET_INT
    SUB [EXPRSP], 3
    SET J, [EXPRSP]
    SET [J], 1              ; int
    SET [J+1], [Y]
    SET [J+2], [Y+1]
    SET PC, switch_code

:VAR_GET_FLOAT
    SUB [EXPRSP], 6
    SET J, [EXPRSP]
    SET [J], 2              ; float
    SET I, Y
    ADD J, 1
    JSR FP_unpack
    SET PC, switch_code

:VAR_GET_STR
    SUB [EXPRSP], [Y]
    SUB [EXPRSP], 2
    SET J, [EXPRSP]
    SET [J], 3
    SET [J+1], [Y]
    SET I, Y
    ADD I, 1
    ADD J, 2
    SET C, [Y]
    JSR fast_copy_block_f
    SET PC, switch_code

:VAR_GET_ARRAY_INT
    SET J, VAR_GET_INT
:VAR_PB_ARRAY_INT
    JSR VAR_CALCINDEX
    IFN [EXPRERR], 0
        SET PC, switch_code
    MUL A, 2
    IFN EX, 0
        SET PC, VAR_CALCINDEX_OVF
    ADD Y, A
    IFN EX, 0
        SET PC, VAR_CALCINDEX_OVF
    IFN [EXPRERR], 0
        SET PC, switch_code
    SET PC, J

:VAR_GET_ARRAY_FLOAT
    SET J, VAR_GET_FLOAT
:VAR_PB_ARRAY_FLOAT
    JSR VAR_CALCINDEX
    IFN [EXPRERR], 0
        SET PC, switch_code
    MUL A, 3
    IFN EX, 0
        SET PC, VAR_CALCINDEX_OVF
    ADD Y, A
    IFN EX, 0
        SET PC, VAR_CALCINDEX_OVF
    IFN [EXPRERR], 0
        SET PC, switch_code
    SET PC, J

:VAR_GET_ARRAY_STR
    SET J, VAR_GET_STR
:VAR_PB_ARRAY_STR
    JSR VAR_CALCINDEX
    IFN [EXPRERR], 0
        SET PC, switch_code
:VAR_GET_ARRAY_STR_PTR
    IFE A, 0
        SET PC, VAR_GET_ARRAY_STR_PTR_END
    ADD Z, [Z]
    ADD Z, 1
    SUB A, 1
    SET PC, VAR_GET_ARRAY_STR_PTR
:VAR_GET_ARRAY_STR_PTR_END
    IFN [EXPRERR], 0
        SET PC, switch_code
    SET PC, J

:VAR_SET
    SET [ARRAYDIM], 0
    JSR switch_vars
    JSR VAR_FIND
    IFE X, 0
        SET PC, VAR_NEW
:VAR_SET_RAW
    JSR switch_vars
    SET [ARRAYDIM], 0
    IFE [VARTYPE], 0x10     ; int
        SET PC, VAR_SET_INT
    IFE [VARTYPE], 0x11     ; float
        SET PC, VAR_SET_FLOAT
    IFE [VARTYPE], 0x12     ; str
        SET PC, VAR_SET_STR
    IFE [VARTYPE], 0x20     ; int
        SET PC, VAR_SET_ARRAY_INT
    IFE [VARTYPE], 0x21     ; float
        SET PC, VAR_SET_ARRAY_FLOAT
    IFE [VARTYPE], 0x22     ; str
        SET PC, VAR_SET_ARRAY_STR
    JSR switch_code
    SET PC, POP

; append variable at J to list
; according to VAR_LAST and VAR_SLIST
:VAR_APPEND
    IFE [VAR_LAST], 0
        SET PC, VAR_NEWLIST
    SET A, [VAR_LAST]
    SET [1+A], J
    SET PC, POP
:VAR_NEWLIST
    SET A, [VAR_SLIST]
    SET [A], J
    SET PC, POP

; create new variable based on VARTYPE
:VAR_NEW
    SET J, [VMEMFPTR]
    ; 3 words for variable header
    ; N words for variable name
    SET C, 3           
    ADD C, [VARLEN]
    JSR VAR_RESERVE
    SET [J], [VARTYPE]
    SET [J+1], 0
    SET [J+2], [VARLEN]
    JSR VAR_APPEND
    SET C, [VARLEN]
    SET I, VARNAME
    ADD J, 3
    SET B, J
    JSR fast_copy_block_f
    ADD B, [VARLEN]
    IFE [VARTYPE], 0x10     ; int
        SET PC, VAR_NEW_INT
    IFE [VARTYPE], 0x11     ; float
        SET PC, VAR_NEW_FLOAT
    IFE [VARTYPE], 0x12     ; str
        SET PC, VAR_NEW_STR
    IFE [VARTYPE], 0x20     ; int
        SET PC, VAR_NEW_ARRAY_INT
    IFE [VARTYPE], 0x21     ; float
        SET PC, VAR_NEW_ARRAY_FLOAT
    IFE [VARTYPE], 0x22     ; str
        SET PC, VAR_NEW_ARRAY_STR
    IFE [VARTYPE], 0x30
        SET Y, B
    JSR switch_code
    SET PC, POP

:VAR_SET_INVALID
    JSR switch_code
    SET PC, error_typemis

:VAR_SET_INVALID_RANGE
    JSR switch_code
    SET PC, error_illegalarg

; set existing int at [Y]
:VAR_SET_INT
    SET X, [EXPRSP]
    IFE [X], 2
        SET PC, VAR_SET_INT_FLOAT
    IFE [X], 3
        SET PC, VAR_SET_INVALID
    SET [Y], [X+1]
    SET [Y+1], [X+2]
    ADD [EXPRSP], 3
    SET PC, switch_code

:VAR_SET_INT_FLOAT
    JSR FP0_load
    JSR FP0_int32_adv
    IFN [FPERROR], 0
        SET PC, VAR_SET_INVALID_RANGE
    SET [Y], [FTMP]
    SET [Y+1], [FTMP+1]
    SET PC, switch_code

; set existing float at [Y]
:VAR_SET_FLOAT
    SET X, [EXPRSP]
    IFE [X], 3
        SET PC, VAR_SET_INVALID
    JSR FP0_loadx
    SET J, FP0
    SET I, Y
    JSR FP_pack
    SET PC, switch_code

; Shift variable block back A bytes starting from I
:VAR_block_b
    SET C, [VMEMFPTR]
    SET J, I
    ADD I, A
    SUB C, I
    SET PC, fast_copy_block_f

; Shift variable block forward A bytes starting from I
:VAR_block_f
    SET C, [VMEMFPTR]
    SUB C, I
    SET J, I
    ADD J, A
    SET PC, fast_copy_block_b_a

; Adjust variable pointers
; Go through all linked lists, and add A to every pointer
; that is above I
:VAR_ADJUST
    IFE A, 0
        SET PC, POP
    SET PUSH, C
    SET PUSH, J
    SET C, VARLIST
:VAR_ADJUST_LOOP
    IFE C, FP0          ; end of VARLIST
        SET PC, VAR_ADJUST_END
    IFG [C], I
        ADD [C], A
    SET J, [C]
    ADD C, 1
:VAR_ADJUST_ILOOP
    IFE J, 0
        SET PC, VAR_ADJUST_LOOP
    IFG [J+1], I
        ADD [J+1], A
    SET J, [J+1]
    SET PC, VAR_ADJUST_ILOOP
:VAR_ADJUST_END
    SET J, POP
    SET C, POP
    SET PC, POP

; set existing STR at [Y]
; involves moving around blocks
:VAR_SET_STR
    SET B, [EXPRSP]
    IFN [B], 3
        SET PC, VAR_SET_INVALID
    IFE [B+1], [Y]
        SET PC, VAR_SET_STR_COPY
    IFG [B+1], [Y]
        SET PC, VAR_SET_STR_MOVE_F
:VAR_SET_STR_MOVE_B
    SET I, Y
    SET A, [B+1]
    SUB A, [Y]
    SET [LLTMPW], A
    JSR LOOP_ADJUST_FOR
    SET A, [Y]
    SUB A, [B+1]
    JSR VAR_block_b
    ADD [VMEMFPTR], [LLTMPW]
    SET PC, VAR_SET_STR_COPY
:VAR_SET_STR_MOVE_F
    SET C, [B+1]
    SUB C, [Y]
    JSR VAR_RESERVE
    SET I, Y
    SET A, [B+1]
    SUB A, [Y]
    SET [LLTMPW], A
    JSR LOOP_ADJUST_FOR
    JSR VAR_block_f
:VAR_SET_STR_COPY
    SET C, [B+1]
    SET [Y], C
    SET J, Y
    ADD J, 1
    SET I, B
    ADD I, 2
    ADD [EXPRSP], C
    ADD [EXPRSP], 2
    JSR fast_copy_block_f
    SET I, Y
    SET A, [LLTMPW]
    JSR VAR_ADJUST
    SET PC, switch_code

:VAR_SET_ARRAY_INT
    SET J, VAR_SET_INT
    SET PC, VAR_PB_ARRAY_INT

:VAR_SET_ARRAY_FLOAT
    SET J, VAR_SET_FLOAT
    SET PC, VAR_PB_ARRAY_FLOAT

:VAR_SET_ARRAY_STR
    SET J, VAR_SET_STR
    SET PC, VAR_PB_ARRAY_STR

; Reserve C bytes in variable heap
; If fails, OOM error
:VAR_RESERVE
    JSR rnd_inc
    SET A, [VMEMEND]
    SUB A, [VMEMFPTR]
    IFL A, C
        SET PC, error_mem
    ADD [VMEMFPTR], C
    SET PC, POP

:VAR_NEW_INT
    SET C, 2
    JSR VAR_RESERVE
    SET X, [EXPRSP]
    IFE [X], 2
        SET PC, VAR_NEW_INT_FLOAT
    IFE [X], 3
        SET PC, VAR_SET_INVALID
    SET [B], [X+1]
    SET [B+1], [X+2]
    ADD [EXPRSP], 3
    SET PC, switch_code

:VAR_NEW_INT_FLOAT
    SET Y, B
    JSR FP0_load
    JSR FP0_int32_adv
    IFN [FPERROR], 0
        SET PC, VAR_SET_INVALID_RANGE
    SET [Y], [FTMP]
    SET [Y+1], [FTMP+1]
    SET PC, switch_code

:VAR_NEW_FLOAT
    SET C, 4
    JSR VAR_RESERVE
    SET X, [EXPRSP]
    IFE [X], 3
        SET PC, VAR_SET_INVALID
    JSR FP0_loadx
    SET J, FP0
    SET I, B
    JSR FP_pack
    SET PC, switch_code

:VAR_NEW_STR
    SET X, [EXPRSP]
    SET C, 1
    ADD C, [X+1]
    JSR VAR_RESERVE
    IFN [X], 3
        SET PC, VAR_SET_INVALID
    ADD X, 1
    SET [B], [X]
    SET I, X
    SET J, B
    STI 0, 0                ; increase I and J
    JSR fast_copy_block_f
    SET PC, switch_code

:VAR_DIM
    SET C, 1
    ADD C, [J]
    JSR VAR_RESERVE
    SET C, [J]
    SET B, Y
    SET [Y], C
    SET I, J
:VAR_DIM_LOOP
    ADD Y, 1
    ADD I, 1
    SET [Y], [I]
    SUB C, 1
    IFG C, 0
        SET PC, VAR_DIM_LOOP
    ADD Y, 1
    SET PUSH, Y
    SET Y, B
    JSR VAR_CALCLEN
    SET Y, POP
    SET PC, POP

:VAR_NEW_ARRAY_INT
    SET J, STR3
    SET [STR3], 1
    SET [STR3+1], 10
    ADD J, [ARRAYDIM]
    SET Y, B
    JSR VAR_DIM
    SET C, A
    MUL C, 2
    JSR VAR_RESERVE
    SET I, Y
    SET A, 0
    JSR mem_fill
    IFN [ARRAYDIM], 0
        SET PC, POP
    SET PC, VAR_SET

:VAR_NEW_ARRAY_FLOAT
    SET J, STR3
    SET [STR3], 1
    SET [STR3+1], 10
    ADD J, [ARRAYDIM]
    SET Y, B
    JSR VAR_DIM
    SET C, A
    MUL C, 3
    JSR VAR_RESERVE
    SET I, Y
    SET A, 0
    JSR mem_fill
    IFN [ARRAYDIM], 0
        SET PC, POP
    SET PC, VAR_SET

:VAR_NEW_ARRAY_STR
    SET J, STR3
    SET [STR3], 1
    SET [STR3+1], 10
    ADD J, [ARRAYDIM]
    SET Y, B
    JSR VAR_DIM
    SET C, A
    JSR VAR_RESERVE
    SET I, Y
    SET A, 0
    JSR mem_fill
    IFN [ARRAYDIM], 0
        SET PC, POP
    SET PC, VAR_SET

; ===========================
; STATEMENTS
; ===========================

:STMT_STOP
    JSR exec_endst          ; end of statement?
    IFE A, 0                ; if not, syntax error
        SET PC, error_syntax
    SET [BREAKFLG], 0xFFFF
    IFN [DIRECTFLG], 0      ; if direct mode...
        SET PC, STMT_STOP_D ; exit now with break flag
    SET PUSH, 0
    SET PUSH, 0
    SET PUSH, 0
    SET PC, breakkey_msg

:STMT_STOP_D                ; full reset
    SET I, msg_break
    JSR txtout
    SET SP, 0               ; reset stack
    SET PC, repl_loop       ; re-enter main loop

:STMT_END
    JSR exec_endst          ; end of statement?
    IFE A, 0                ; if not, syntax error
        SET PC, error_syntax
    SET [BREAKFLG], 0xFFFF
    IFE [DIRECTFLG], 0xFFFF ; if direct mode...
        SET PC, STMT_END_D  ; exit now with break flag
    IFN [RUNNING], 0
        SET [RUNNING], 1    ; can CONT
    SET [EXECPTR], Z        ; save Z
    SET [readyflag], 1      ; print Ok.
    JSR repl_loop           ; main loop with CONT
    SET PC, POP             ; CONT returns here if triggered

:STMT_END_D                 ; full reset
    SET SP, 0               ; reset stack
    SET PC, repl_loop       ; re-enter main loop

:STMT_CONT
    JSR exec_endst          ; end of statement?
    IFE A, 0                ; if not, syntax error
        SET PC, error_syntax
    IFE [RUNNING], 0        ; cannot continue?
        SET PC, STMT_CONT_N
    IFN [RUNNING], 1        ; already running?
        SET PC, POP
    ; stack status:
    ; BREAK:        JSR repl_loop
    ; repl_loop:    JSR parseln
    ; parseln:      JSR executeln
    ; executeln:    JSR [A+stmt_table]
    ; to reaccess BREAK, we must pop
    ; 3 items from stack
    SET 0, POP
    SET 0, POP
    SET 0, POP
    SET [DIRECTFLG], 0
    SET [RUNNING], 0xFFFF   ; running again
    SET Z, [EXECPTR]        ; restore Z
    SET PC, POP

:STMT_CONT_N
    SET A, 16               ; can't continue
    SET PC, error_fatal

:STMT_DIM
    JSR exec_endst
    IFN A, 0                ; if is, finish
        SET PC, error_syntax
    JSR skipspc
    JSR exec_var
    IFL [VARTYPE], 0x20     ; not array?
        SET PC, STMT_DIM_N  ; no dimensions
    JSR switch_vars
    JSR VAR_FIND
    IFN X, 0                ; redim'd
        SET PC, STMT_DIM_R
    SET [ARRAYDIM], 255     ; read from STR3+255 buffer
    JSR VAR_NEW             ; create & dimension array
    JSR switch_code
:STMT_DIM_N
    JSR exec_endst
    IFN A, 0                ; if is, finish
        SET PC, POP
    JSR skipspc
    IFN [Z], 0x002c         ; ","
        SET PC, error_syntax
    ADD Z, 1
    SET PC, STMT_DIM

:STMT_DIM_R
    JSR switch_code
    SET A, 10
    SET PC, error_fatal_curln

:STMT_READ_ZI
    ADD Z, 1
:STMT_READ
    SET [EXPRSP], SYS_STACK
    JSR skipspc
    JSR exec_endst
    IFN A, 0                ; if is, finish
        SET PC, error_syntax
    JSR exec_var
    IFE [VARTYPE], 0x00     ; not variable?
        SET PC, error_syntax
    SET A, [VARTYPE]
    AND A, 0x0F
    IFE A, 0x00             ; int?
        SET PC, STMT_READ_C_I
    IFE A, 0x01             ; float?
        SET PC, STMT_READ_C_F
    IFE A, 0x02             ; str?
        SET PC, STMT_READ_C_S
:STMT_READ_C
    JSR skipspc
    IFE [Z], 0x002c         ; comma
        SET PC, STMT_READ_ZI
    JSR exec_endst
    IFE A, 0                ; if isn't, finish
        SET PC, error_syntax
    SET PC, POP

:STMT_READ_C_I
    JSR STMT_READ_I
    SET PC, STMT_READ_C
:STMT_READ_C_F
    JSR STMT_READ_F
    SET PC, STMT_READ_C
:STMT_READ_C_S
    JSR STMT_READ_S
    SET PC, STMT_READ_C

:STMT_INPUT_I
    SET [BTMP], 0xFFFF
    JSR skipspc
    SET A, Z
    JSR str_num
    SET PC, STMT_READ_I_RAW
:STMT_READ_I
    SET [BTMP], 0
    JSR skipspc
    JSR data_next
    SET PUSH, Z
    SET Z, [DATAPTR]
    JSR skipspc
    SET A, Z
    IFE [A], 0x0025
        SET PC, STMT_READ_N_BIN
    IFE [A], 0x0026
        SET PC, STMT_READ_N_HEX
    JSR str_num
    SET [DATAPTR], I
    SET Z, POP
:STMT_READ_I_RAW
    IFE A, 0x0002           
        SET PC, STMT_READ_I_F
    IFE A, 0xFFFE           ; FP error
        SET PC, error_fp
    IFN A, 1                ; illegal, other error etc.
        IFE [BTMP], 0
            SET PC, error_typemis
    IFN A, 1                ; illegal, other error etc.
        IFN [BTMP], 0
            SET PC, STMT_INPUT_RETRY
:STMT_READ_F_I
    SUB [EXPRSP], 3
    SET X, [EXPRSP]
    SET [X], 1
    SET [X+1], [FTMP]
    SET [X+2], [FTMP+1]
    JSR VAR_SET
    SET PC, POP
:STMT_INPUT_F
    SET [BTMP], 0xFFFF
    JSR skipspc
    SET A, Z
    JSR str_num
    SET PC, STMT_READ_F_RAW
:STMT_READ_F
    SET [BTMP], 0
    JSR skipspc
    JSR data_next
    SET PUSH, Z
    SET Z, [DATAPTR]
    JSR skipspc
    SET A, Z
    IFE [A], 0x0025
        SET PC, STMT_READ_N_BIN
    IFE [A], 0x0026
        SET PC, STMT_READ_N_HEX
    JSR str_num
    SET [DATAPTR], I
    SET Z, POP
:STMT_READ_F_RAW
    IFE A, 0xFFFE           ; FP error
        SET PC, error_fp
    IFN A, 1                ; illegal, other error etc.
        IFN A, 2
            IFE [BTMP], 0
                SET PC, error_typemis
    IFN A, 1                ; illegal, other error etc.
        IFN A, 2
            IFN [BTMP], 0
                SET PC, STMT_INPUT_RETRY
    IFE A, 1
        SET PC, STMT_READ_F_I
    JSR FP0_store
    JSR VAR_SET
    SET PC, POP
:STMT_INPUT_S
    SET [BTMP], 0xFFFF
    SET PC, STMT_READ_S_RAW
:STMT_READ_S
    SET [BTMP], 0
    JSR skipspc
    JSR data_next
    SET PUSH, Z
    SET Z, [DATAPTR]
:STMT_READ_S_RAW
    JSR skipspc
    IFE [Z], 0x0022         ; "
        SET PC, STMT_READ_S_Q
    SET I, Z
:STMT_READ_S_L
    JSR exec_enddata
    IFN A, 0
        SET PC, STMT_READ_S_E
    ADD Z, 1
    SET PC, STMT_READ_S_L
:STMT_READ_S_E
    SET C, Z
    SUB C, I
    SUB [EXPRSP], 2
    SUB [EXPRSP], C
    SET X, [EXPRSP]
    SET [X], 3
    SET [X+1], C
    SET J, X
    ADD J, 2
    JSR fast_copy_block_f
    JSR VAR_SET
    IFN [BTMP], 0
        SET PC, POP
    SET [DATAPTR], Z
    SET Z, POP
    SET PC, POP

:STMT_READ_S_Q
    ADD Z, 1
    SET I, Z
:STMT_READ_S_QL
    IFE [Z], 0x0022         ; "
        SET PC, STMT_READ_S_QE
    IFE [Z], 0xFFFF         ; <end>
        SET PC, STMT_READ_S_QE
    ADD Z, 1
    SET PC, STMT_READ_S_QL
:STMT_READ_S_QE
    SET C, Z
    SUB C, I
    SUB [EXPRSP], 2
    SUB [EXPRSP], C
    SET X, [EXPRSP]
    SET [X], 3
    SET [X+1], C
    SET J, X
    ADD J, 2
    JSR fast_copy_block_f
    IFE [Z], 0x0022         ; "
        ADD Z, 1
    JSR VAR_SET
    IFN [BTMP], 0
        SET PC, POP
    SET [DATAPTR], Z
    SET Z, POP
    SET PC, POP

:STMT_READ_I_F
    JSR FP0_int32_adv
    IFN [FPERROR], 0
        SET PC, error_illegalarg
    SET PC, STMT_READ_F_I

:STMT_READ_N_BIN
    JSR exec_expr_val_bin
    SET [DATAPTR], Z
    JSR VAR_SET
    SET Z, POP
    SET PC, POP

:STMT_READ_N_HEX
    JSR exec_expr_val_hex
    SET [DATAPTR], Z
    JSR VAR_SET
    SET Z, POP
    SET PC, POP

:STMT_RESTORE
    IFN [DIRECTFLG], 0
        SET PC, error_direct
    JSR exec_endst          ; end of statement?
    IFN A, 0                ; if is, finish
        SET PC, STMT_RESTORE_N
    JSR exec_expr
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    SET X, [EXPRSP]
    JSR exec_endst          ; end of statement?
    IFE A, 0                ; if not, finish
        SET PC, error_syntax
    IFN [X], 1
        SET PC, error_typemis
    IFN [X+2], 0            ; >=2^16?
        SET PC, error_noln  ; No such line
    SET [RESULTLN], [X+1]
    SET A, [X+1]
    JSR line_find           ; Find given line
    IFE I, [PMEMFPTR]       ; Not found?
        SET PC, error_noln  ; No such line
    ADD [EXPRSP], 3
    ADD I, 2
    SET [DATAPTR], I
    SET [DATASTMT], 0
    SET PC, POP             

:STMT_RESTORE_N
    SET [DATAPTR], [PMEMSPTR]
    SET [DATASTMT], 0
    SET PC, POP

:STMT_LET                   ; LET var[(...)]=expr
    SET 0, POP              ; destroy JSR [A+stmt_table]
    SET PC, executeln_check_var

:STMT_REM
    IFE [Z], 0xFFFF
        SET PC, STMT_REM_E
    ADD Z, 1
    SET PC, STMT_REM
:STMT_REM_E
    SET PC, POP

:STMT_DATA_I
    ADD Z, 1
:STMT_DATA
    JSR exec_endst
    IFN A, 0
        SET PC, STMT_DATA_E
    IFE [Z], 0x0022         ; quotes
        SET PC, STMT_DATA_QI
    ADD Z, 1
    SET PC, STMT_DATA
:STMT_DATA_E
    SET PC, POP

:STMT_DATA_QI
    ADD Z, 1
:STMT_DATA_Q
    IFE [Z], 0xFFFF
        SET PC, STMT_DATA_E
    IFE [Z], 0x0022         ; quotes
        SET PC, STMT_DATA_I
    ADD Z, 1
    SET PC, STMT_DATA_Q

:STMT_INPUT
    SET [EXPRSP], SYS_STACK
    IFL SP, SYS_STACK_LM
        SET PC, error_mem
    SET [INPUTORIG], Z
    SET [INPUTPOS], 0
    JSR skipspc
    IFN [Z], 0x0022         ; "
        SET PC, STMT_INPUT_IN
    JSR exec_expr
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    JSR OP_TO_STR
    SET X, [EXPRSP]
    ADD [EXPRSP], 2         ; remove string from stack
    ADD [EXPRSP], [X+1]
    SET C, [X+1]
    SET I, X
    ADD I, 2
:STMT_INPUT_L
    IFE C, 0
        SET PC, STMT_INPUT_NE
    STI A, [I]
    JSR chrout
    SUB C, 1
    SET PC, STMT_INPUT_L
:STMT_INPUT_NE
    JSR skipspc
    IFN [Z], 0x003b         ; semicolon
        SET PC, error_syntax
    ADD Z, 1
    JSR skipspc
    SET PC, STMT_INPUT_IN
:STMT_INPUT_NC
    JSR skipspc
    IFN [Z], 0x002c         ; comma
        SET PC, error_syntax
    ADD Z, 1
    JSR skipspc
:STMT_INPUT_N
    JSR exec_endst
    IFN A, 0
        SET PC, error_syntax
    JSR exec_var
    IFE [VARTYPE], 0x00
        SET PC, error_syntax
    SET A, 0
    IFN [INPUTPOS], 0
        SET A, 0x003F       ; '?'
    JSR chrout
    SET A, 0x003F           ; '?'
    JSR chrout
    SET A, 0x0016           ; input header
    JSR chrout
    JSR readln
    SET J, STR1
:STMT_INPUT_CL
    SET A, [I]
    AND A, 0x00FF
    IFE A, 0x00FF
        SET PC, STMT_INPUT_CE
    STI [J], A
    SET PC, STMT_INPUT_CL
:STMT_INPUT_CE
    SET [J], 0xFFFF
    SET I, STR1
    IFE [I], 0xFFFF
        SET PC, STMT_INPUT_CEZ
    SET A, [VARTYPE]
    AND A, 0x0F
    IFE A, 0x00             ; int
        SET PC, STMT_INPUT_CE_I
    IFE A, 0x01             ; float
        SET PC, STMT_INPUT_CE_F
    IFE A, 0x02             ; str
        SET PC, STMT_INPUT_CE_S
:STMT_INPUT_CEZ
    ADD [INPUTPOS], 1
    JSR skipspc
    IFE [Z], 0x002c
        SET PC, STMT_INPUT_NC
    SET PC, POP

:STMT_INPUT_CE_I
    SET PUSH, Z
    SET Z, STR1
    JSR STMT_INPUT_I
    SET Z, POP
    SET PC, STMT_INPUT_CEZ
:STMT_INPUT_CE_F
    SET PUSH, Z
    SET Z, STR1
    JSR STMT_INPUT_F
    SET Z, POP
    SET PC, STMT_INPUT_CEZ
:STMT_INPUT_CE_S
    SET PUSH, Z
    SET Z, STR1
    JSR STMT_INPUT_S
    SET Z, POP
    SET PC, STMT_INPUT_CEZ
:STMT_INPUT_RETRY
    SET 0, POP
    SET 0, POP
    SET I, msg_input_invalid
    JSR txtout
    SET Z, [INPUTORIG]
    SET PC, STMT_INPUT

:STMT_INPUT_IN
    JSR exec_endst
    IFE A, 0
        SET PC, STMT_INPUT_N

:STMT_GET
    SET [EXPRSP], SYS_STACK
    SET PUSH, Z
    JSR exec_endst          ; end of statement?
    IFN A, 0                ; if is, finish
        SET PC, STMT_GET_KEYP
    JSR exec_var
    IFE [VARTYPE], 0
        SET PC, error_syntax
    JSR exec_endst          ; end of statement?
    IFE A, 0                ; if not, syntax error
        SET PC, error_syntax
    SET A, [VARTYPE]
    AND A, 0x000F
    IFE A, 0x0002
        SET PC, STMT_GET_S
:STMT_GET_KEYL
    SET A, 1
    HWI [DEVKEYB]
    IFE C, 0
        SET PC, STMT_GET_KEYL
    IFE C, 0x13             ; break
        SET PC, STMT_GET_BREAK
    SET 0, POP
    SUB [EXPRSP], 3
    SET X, [EXPRSP]
    SET [X], 1
    SET [X+1], C
    SET [X+2], 0
    JSR VAR_SET
    SET PC, POP

:STMT_GET_S
    SET A, 1
    HWI [DEVKEYB]
    IFE C, 0x13             ; break
        SET PC, STMT_GET_BREAK
    IFE C, 0x12             ; fn
        SET PC, STMT_GET_S
    IFG C, 0x100            ; special key
        SET PC, STMT_GET_S
    SET 0, POP
    IFE C, 0
        SET PC, STMT_GET_S_EMPTY
    SUB [EXPRSP], 3
    SET X, [EXPRSP]
    SET [X], 3
    SET [X+1], 1
    SET [X+2], C
    JSR VAR_SET
    SET PC, POP

:STMT_GET_S_EMPTY
    SUB [EXPRSP], 2
    SET X, [EXPRSP]
    SET [X], 3
    SET [X+1], 1
    JSR VAR_SET
    SET PC, POP

:STMT_GET_KEYP
    SET A, 1
    HWI [DEVKEYB]
    IFE C, 0
        SET PC, STMT_GET_KEYP
    IFE C, 0x13             ; break
        SET PC, STMT_GET_BREAK
    SET 0, POP
    SET PC, POP

:STMT_GET_BREAK
    SET PUSH, 0
    SET PUSH, 0
    SET PUSH, 0
    JSR breakkey_msg
    SET Z, POP
    SET PC, STMT_GET

:STMT_GOTO
    IFN [DIRECTFLG], 0
        SET PC, STMT_RUN
    JSR exec_endst          ; end of statement?
    IFN A, 0                ; if is, finish
        SET PC, error_syntax
    JSR exec_expr
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    JSR exec_endst          ; end of statement?
    IFE A, 0                ; if not, finish
        SET PC, error_syntax
    JSR OP_TO_INT
    SET X, [EXPRSP]
    IFN [X], 1
        SET PC, error_typemis
    IFN [X+2], 0            ; >=2^16?
        SET PC, error_noln  ; No such line
    SET [RESULTLN], [X+1]
    SET A, [X+1]
    JSR line_find           ; Find given line
    IFE I, [PMEMFPTR]       ; Not found?
        SET PC, error_noln  ; No such line
    ADD [EXPRSP], 3
    SET [JUMPING], 1
    SET [EXECPTR], I        ; reassign execution pointer
    SET 0, POP              ; remove executeln
    SET PC, POP             ; -> runprog (_assign)

:STMT_RUN
    SET [RESULTLN], 0       ; start from line 0
    JSR exec_endst          ; end of statement?
    IFN A, 0                ; if is, finish
        SET PC, STMT_RUN_E
    JSR exec_nnint          ; get line number?
    IFE A, 0                ; if invalid, syntax error
        SET PC, error_syntax
    JSR exec_endst          ; end of statement?
    IFE A, 0                ; if not, finish
        SET PC, error_syntax
    IFN [BTMP+0], 0         ; >=2^32?
        SET PC, error_noln  ; No such line
    IFN [BTMP+1], 0         ; >=2^16?
        SET PC, error_noln  ; No such line
    SET [RESULTLN], [BTMP+2]
    SET A, [BTMP+2]
    JSR line_find           ; Find given line
    IFE I, [PMEMFPTR]       ; Not found?
        SET PC, error_noln  ; No such line
:STMT_RUN_E
    IFE [DIRECTFLG], 0xFFFF ; if direct mode...
        SET PC, STMT_RUN_D  ; exit now with break flag
    SET [JUMPING], 1
    SET 0, POP
    SET 0, POP
    SET 0, POP
    SET PC, runprog
:STMT_RUN_D
    ; stack status (direct mode):
    ; repl_loop:    JSR parseln
    ; parseln:      JSR executeln
    ; executeln:    JSR [A+stmt_table]
    SET [JUMPING], 1
    SET 0, POP
    SET 0, POP
    SET PC, runprog

:STMT_IF
    JSR skipspc
    JSR exec_endst          ; end of statement?
    IFN A, 0                ; if is, finish
        SET PC, error_syntax
    JSR exec_expr
    JSR skipspc
    SET X, [EXPRSP]
    IFE [X], 1
        IFE [X+1], 0
            IFE [X+2], 0
                SET PC, STMT_IF_SKIP
    IFE [X], 2
        IFE [X+1], 0
            SET PC, STMT_IF_SKIP
    IFE [X], 3
        IFE [X+1], 0
            SET PC, STMT_IF_SKIP
    IFE [Z], 0x2005         ; THEN
        SET PC, STMT_IF_THEN
    IFE [Z], 0x1008         ; GOTO
        SET PC, STMT_IF_RET
    SET PC, error_syntax
:STMT_IF_THEN
    ADD Z, 1
    JSR skipspc
    IFG [Z], 0x002F         ; '0'-1
        IFL [Z], 0x003A     ; '9'+1
            SET PC, STMT_GOTO 
:STMT_IF_RET
    SET PC, POP
:STMT_IF_SKIP
    SET PC, STMT_REM

:STMT_GOSUB
    IFN [DIRECTFLG], 0
        SET PC, error_direct
    JSR exec_endst          ; end of statement?
    IFN A, 0                ; if is, finish
        SET PC, error_syntax
    JSR exec_expr
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    JSR exec_endst          ; end of statement?
    IFE A, 0                ; if not, finish
        SET PC, error_syntax
    JSR OP_TO_INT
    SET X, [EXPRSP]
    IFN [X], 1
        SET PC, error_typemis
    IFN [X+2], 0            ; >=2^16?
        SET PC, error_noln  ; No such line
    SET [RESULTLN], [X+1]
    SET A, [X+1]
    JSR line_find           ; Find given line
    IFE I, [PMEMFPTR]       ; Not found?
        SET PC, error_noln  ; No such line
    ADD [EXPRSP], 3

    ; push values for RETURN back into stack
    SUB [LOOPSP], 3
    IFL [LOOPSP], LOOP_STACK_LM
        SET PC, error_mem
    SET X, [LOOPSP]
    SET [X], 0x100c         ; GOSUB
    SET [X+1], Z
    SET [X+2], [CURLINE]

    SET [JUMPING], 1
    SET [EXECPTR], I        ; reassign execution pointer
    SET 0, POP              ; remove executeln
    SET PC, POP             ; -> runprog (_assign)

:STMT_RETURN
    IFN [DIRECTFLG], 0
        SET PC, error_direct
    JSR exec_endst          ; end of statement?
    IFE A, 0                ; if not, syntax error
        SET PC, error_syntax
    JSR LOOP_FIND_GOSUB
    IFE X, 0
        SET PC, STMT_RETURN_E
    IFN [X], 0x100c         ; GOSUB
        SET PC, STMT_RETURN_E
    SET Z, [X+1]
    SET [CURLINE], [X+2]
    ADD [LOOPSP], 3
    SET PC, POP

:STMT_RETURN_E
    SET A, 3
    SET PC, error_fatal_curln

:STMT_FOR
    JSR exec_endst          ; end of statement?
    IFN A, 0                ; if is, syntax error
        SET PC, error_syntax
    JSR skipspc
    JSR exec_var
    IFE [VARTYPE], 0        ; not valid?
        SET PC, error_syntax
    IFG [VARTYPE], 0x11     ; no arrays or string variable allowed
        SET PC, error_syntax
    SET C, 17
    SET I, VARTYPE
    SET J, VARBACKUP
    JSR fast_copy_block_f
    JSR skipspc
    IFN [Z], 0x4010         ; "="
        SET PC, error_syntax
    ADD Z, 1
    JSR exec_expr
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    SET X, [EXPRSP]
    IFE [X], 3              ; must not be string
        SET PC, error_syntax
    SET C, 17
    SET I, VARBACKUP
    SET J, VARTYPE
    JSR fast_copy_block_f
    JSR VAR_SET             ; store variable
    JSR switch_vars
    JSR VAR_FIND            ; get variable pointer
    JSR switch_code
    SET A, X
    SUB [LOOPSP], 14
    IFL [LOOPSP], LOOP_STACK_LM
        SET PC, error_mem
    SET X, [LOOPSP]
    SET [X], 0x1001         ; FOR
    SET [X+1], A            ; variable pointer
    JSR skipspc
    IFN [Z], 0x2002         ; TO
        SET PC, error_syntax
    ADD Z, 1
    JSR exec_expr
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    SET X, [EXPRSP]
    IFE [X], 3              ; must not be string
        SET PC, error_syntax
    JSR FP0_loadx           ; convert to FP
    JSR FP0_store
    SET X, [EXPRSP]
    SET A, [LOOPSP]
    SET [A+4], [X+1]
    SET [A+5], [X+2]
    SET [A+6], [X+3]
    SET [A+7], [X+4]
    SET [A+8], [X+5]
    SET [A+9],  0x0081
    SET [A+10], 0x0000      ; default STEP = 1
    SET [A+11], 0x8000
    SET [A+12], 0x0000
    SET [A+13], 0x0000
    ADD [EXPRSP], 6         ; remove END
    IFN [Z], 0x2007         ; STEP
        SET PC, STMT_FOR_NS
    ADD Z, 1
    JSR exec_expr
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    SET X, [EXPRSP]
    IFE [X], 3              ; must not be string
        SET PC, error_syntax
    JSR FP0_loadx           ; convert to FP
    JSR FP0_store
    SET X, [EXPRSP]
    SET A, [LOOPSP]
    SET [A+9], [X+1]
    SET [A+10], [X+2]
    SET [A+11], [X+3]
    SET [A+12], [X+4]
    SET [A+13], [X+5]
    ADD [EXPRSP], 6         ; remove STEP
:STMT_FOR_NS
    JSR exec_endst          ; end of statement?
    IFE A, 0                ; if not, syntax error
        SET PC, error_syntax
    SET A, [LOOPSP]
    SET [A+2], Z
    SET [A+3], [CURLINE]
    SET PC, POP

:STMT_NEXT
    SET [EXPRSP], SYS_STACK     ; end of EXPR_STACK
    SET [VARLEN], 0
    JSR exec_endst          ; end of statement?
    IFN A, 0                ; if is, no variable
        SET PC, STMT_NEXT_NV
    JSR exec_var
    IFE [VARTYPE], 0        ; not valid?
        SET PC, error_syntax
    IFG [VARTYPE], 0x11     ; no arrays or string variable allowed
        SET PC, error_syntax
    JSR skipspc
    JSR exec_endst          ; end of statement?
    IFE A, 0                ; if not, syntax
        SET PC, error_syntax
:STMT_NEXT_NV
    JSR LOOP_FIND_FOR
    IFE X, 0
        SET PC, STMT_NEXT_F
    SET [STMT_NEXT_P], X
    JSR switch_vars
    SET A, [X+1]
    SET [VARTYPE], [A]
    SET X, A
    SET Y, X
    ADD Y, [Y+2]
    ADD Y, 3
    JSR VAR_GET_RAW
    SUB [EXPRSP], 6
    SET Y, [EXPRSP]
    SET X, [STMT_NEXT_P]
    SET [Y], 2
    SET [Y+1], [X+9]
    SET [Y+2], [X+10]
    SET [Y+3], [X+11]
    SET [Y+4], [X+12]
    SET [Y+5], [X+13]
    JSR OP_ADD
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    JSR EXPR_DUP
    IFL [EXPRSP], EXPR_STACK_LM
        SET PC, error_mem
    SET X, [STMT_NEXT_P]
    SET X, [X+1]
    JSR switch_vars
    SET Y, X
    ADD Y, [Y+2]
    ADD Y, 3
    JSR VAR_SET_RAW
    SET X, [STMT_NEXT_P]
    IFU [X+7], 0
        SET PC, STMT_NEXT_LT
:STMT_NEXT_GT
    SUB [EXPRSP], 3
    SET Y, [EXPRSP]
    SET [Y], 2
    SET [Y+1], [X+4]
    SET [Y+2], [X+5]
    SET [Y+3], [X+6]
    SET [Y+4], [X+7]
    SET [Y+5], [X+8]
    JSR OP_GT
    SET PC, STMT_NEXT_C
:STMT_NEXT_LT
    SUB [EXPRSP], 3
    SET Y, [EXPRSP]
    SET [Y], 2
    SET [Y+1], [X+4]
    SET [Y+2], [X+5]
    SET [Y+3], [X+6]
    SET [Y+4], [X+7]
    SET [Y+5], [X+8]
    JSR OP_GT
:STMT_NEXT_C
    SET Y, [EXPRSP]
    ADD [EXPRSP], 3
    IFE [Y+1], 0
        SET PC, STMT_NEXT_R
    SET [LOOPSP], [STMT_NEXT_P]     ; remove to current FOR
    ADD [LOOPSP], 14                ; remove current FOR
    SET PC, POP
:STMT_NEXT_R
    ; continue FOR loop
    SET [LOOPSP], [STMT_NEXT_P]     ; remove to current FOR
    SET X, [STMT_NEXT_P]
    SET Z, [X+2]
    SET [CURLINE], [X+3]
    SET PC, POP
:STMT_NEXT_P
    DAT 0
:STMT_NEXT_F
    SET A, 1
    SET PC, error_fatal_curln

; duplicates int or float item at EXPRSP
:EXPR_DUP
    SET A, [EXPRSP]
    IFE [A], 1
        SET PC, EXPR_DUP_INT
    IFE [A], 2
        SET PC, EXPR_DUP_FLOAT
    SET PC, POP
:EXPR_DUP_INT
    SUB [EXPRSP], 3
    SET A, [EXPRSP]
    SET [A], 1
    SET [A+1], [A+4]
    SET [A+2], [A+5]
    SET PC, POP
:EXPR_DUP_FLOAT
    SUB [EXPRSP], 6
    SET A, [EXPRSP]
    SET [A], 2
    SET [A+1], [A+7]
    SET [A+2], [A+8]
    SET [A+3], [A+9]
    SET [A+4], [A+10]
    SET [A+5], [A+11]
    SET PC, POP

; Find FOR in loop stack, result in X (or 0 if not found)
; variable pointer must match
; FOR in loop stack:
;     0000: TK_FOR (0x1001)
;     0001: pointer for the variable entry
;     0002: execution pointer to start of FOR block
;     0003: line number of start of FOR block
;     0004: \ END value  (FP)
;     ...
;     0008: /
;     0009: \ STEP value  
;     000D: /
:LOOP_FIND_FOR
    IFE [VARLEN], 0
        SET PC, LOOP_FIND_FOR_NOVP
    JSR switch_vars
    JSR VAR_FIND
    JSR switch_code
    SET [LOOP_FIND_FOR_VP], X
    IFE X, 0
        SET PC, LOOP_FIND_NOT_FOUND
:LOOP_FIND_FOR_NOVP
    SET X, [LOOPSP]
:LOOP_FIND_FOR_LOOP
    IFG X, EXPR_STACK       ; end of loop stack
        SET PC, LOOP_FIND_NOT_FOUND
    IFE X, EXPR_STACK       ; end of loop stack
        SET PC, LOOP_FIND_NOT_FOUND
    IFE [X], 0x100c         ; GOSUB
        SET PC, LOOP_FIND_NOT_FOUND
    IFE [X], 0x1001         ; FOR
        SET PC, LOOP_FIND_FOR_CANDIDATE
    SET PC, LOOP_FIND_FOR_LOOP
:LOOP_FIND_FOR_CANDIDATE
    IFE [VARLEN], 0
        SET PC, POP
    IFN [X+1], [LOOP_FIND_FOR_VP]
        SET PC, LOOP_FIND_FOR_CANDIDATE_FAIL
    SET PC, POP
:LOOP_FIND_FOR_CANDIDATE_FAIL
    ADD X, 14
    SET PC, LOOP_FIND_FOR_LOOP
:LOOP_FIND_FOR_VP
    DAT 0

; Adjust variable pointers for FOR loops above I, adding A to each
:LOOP_ADJUST_FOR
    SET PUSH, J
    SET J, [LOOPSP]
:LOOP_ADJUST_FOR_LOOP
    IFE J, EXPR_STACK       ; end of loop stack
        SET PC, LOOP_ADJUST_FOR_END
    IFE [J], 0x1001         
        SET PC, LOOP_ADJUST_FOR_FOUND          
    IFE [J], 0x100c         ; GOSUB: 3 words   
        ADD J, 3
    SET PC, LOOP_ADJUST_FOR_LOOP
:LOOP_ADJUST_FOR_FOUND
    IFL [J+1], I
        SET PC, LOOP_ADJUST_FOR_FOUND_DONE
    ADD [J+1], A
:LOOP_ADJUST_FOR_FOUND_DONE
    ADD J, 14
    SET PC, LOOP_ADJUST_FOR_LOOP
:LOOP_ADJUST_FOR_END
    SET J, POP
    SET PC, POP

; Find GOSUB in loop stack, result in X (or 0 if not found)
; GOSUB in loop stack:
;     0000: TK_GOSUB (0x100c)
;     0001: old execution pointer
;     0002: old line number
:LOOP_FIND_GOSUB
    SET X, [LOOPSP]
:LOOP_FIND_GOSUB_LOOP
    IFE X, EXPR_STACK       ; end of loop stack
        SET PC, LOOP_FIND_NOT_FOUND
    IFE [X], 0x100c         ; GOSUB
        SET PC, POP
    IFE [X], 0x1001         ; FOR
        ADD X, 14           ; FOR entry is 14 words long
    SET PC, LOOP_FIND_GOSUB_LOOP
:LOOP_FIND_NOT_FOUND
    SET X, 0
    SET PC, POP

:STMT_LIST_TMP
    DAT 0
:STMT_LIST
    JSR exec_endst          ; end of statement?
    IFN A, 0                ; if is, finish
        SET PC, STMT_LIST_D
    IFE [Z], 0x4001         ; - (OP MINUS)
        SET PC, STMT_LIST_UB
    JSR exec_nnint          ; get line number A
    IFE A, 0                ; if invalid, syntax error
        SET PC, error_syntax
    JSR exec_endst          ; end of statement?
    IFN A, 0                ; if is, finish
        SET PC, STMT_LIST_LN
    IFN [Z], 0x4001         ; - (OP MINUS)
        SET PC, error_syntax
    ADD Z, 1
    JSR exec_endst          ; end of statement?
    IFN A, 0                ; if is, finish
        SET PC, STMT_LIST_LB
    SET [STMT_LIST_TMP], [BTMP+2]
    JSR exec_nnint
    IFE A, 0                ; if invalid, syntax error
        SET PC, error_syntax
    JSR exec_endst          ; end of statement?
    IFE A, 0                ; if isn't, syntax error
        SET PC, error_syntax
    SET B, [STMT_LIST_TMP]
    SET C, [BTMP+2]
    SET PC, prog_listing
:STMT_LIST_D
    SET B, 0
    SET C, 0xFFFF
    SET PC, prog_listing
:STMT_LIST_LN
    SET B, [BTMP+2]
    SET C, [BTMP+2]
    SET PC, prog_listing
:STMT_LIST_LB
    SET B, [BTMP+2]
    SET C, 0xFFFF
    SET PC, prog_listing
:STMT_LIST_UB
    ADD Z, 1
    SET B, 0
    JSR exec_nnint          ; get line number A
    IFE A, 0                ; if invalid, syntax error
        SET PC, error_syntax
    SET C, [BTMP+2]
    SET PC, prog_listing
    
:STMT_CLR
    JSR exec_endst          ; end of statement?
    IFE A, 0                ; if isn't
        SET PC, error_syntax
    SET [readyflag], 1
    JSR BASIC_CLR_RAW
    SET PC, POP
    
:STMT_NEW
    JSR exec_endst          ; end of statement?
    IFE A, 0                ; if isn't
        SET PC, error_syntax
    SET [readyflag], 1
    JSR BASIC_NEW_RAW
    SET PC, POP

:STMT_PRINT
    SET [BTMP+13], 1
:STMT_PRINT_X
    JSR exec_endst          ; end of statement?
    IFN A, 0                ; if is
        SET PC, STMT_PRINT_NL
    SET [BTMP+13], 0
    IFE [Z], 0x003b         ; semicolon (;)
        SET PC, STMT_PRINT_Z
    SET [BTMP+13], 1
    IFE [Z], 0x002c         ; comma (,)
        SET PC, STMT_PRINT_CM
    JSR exec_expr
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    JSR OP_TO_STR
    SET X, [EXPRSP]
    ADD [EXPRSP], 2         ; remove string from stack
    ADD [EXPRSP], [X+1]
    ; print string
    SET C, [X+1]
    SET I, X
    ADD I, 2
:STMT_PRINT_L
    IFE C, 0
        SET PC, STMT_PRINT_N
    STI A, [I]
    JSR chrout
    SUB C, 1
    SET PC, STMT_PRINT_L
:STMT_PRINT_N
    JSR exec_endst          ; end of statement?
    IFE A, 0                ; if isn't
        SET PC, STMT_PRINT_X
:STMT_PRINT_NL
    IFE [BTMP+13], 0
        SET PC, POP
    SET A, 0x11             ; ENTER
    SET PC, chrout
:STMT_PRINT_CM
    SET A, 0x9              ; TAB
    JSR chrout
:STMT_PRINT_Z
    ADD Z, 1
    SET PC, STMT_PRINT_X
    
:STMT_CLS
    JSR reset_screen
    SET [DISPCURSOR], 0
    JSR update_cursor
    SET [readyflag], 1
    SET PC, POP

:STMT_DEF  
    IFN [DIRECTFLG], 0      ; not allowed in direct mode
        SET PC, error_direct
    JSR exec_endst          ; end of statement?
    IFN A, 0                ; if is, finish
        SET PC, error_syntax
    JSR skipspc             
    IFN [Z], 0x2003         ; must be followed by FN
        SET PC, error_syntax
    ADD Z, 1
    JSR skipspc 
    SET [NOARRAY], 1            
    JSR exec_var
    ; vARTYPE must be 0x11
    IFN [VARTYPE], 0x11
        SET PC, error_syntax
    SET [VARTYPE], 0x30     ; function type
    JSR VAR_SET             ; data pointer now in Y
    JSR switch_vars         ; setting some flags
    SET C, 3
    JSR VAR_RESERVE
    SET [Y], 0
    SET [Y+1], [CURLINE]
    JSR switch_code         ; scan parameter
    SET PUSH, Y
    JSR skipspc
    IFN [Z], 0x0028         ; (
        SET PC, error_syntax
    ADD Z, 1
    JSR exec_var
    ; vARTYPE must be 0x11
    IFN [VARTYPE], 0x11
        SET PC, error_syntax
    JSR skipspc
    IFN [Z], 0x0029         ; )
        SET PC, error_syntax
    ADD Z, 1
    JSR skipspc
    IFN [Z], 0x4010         ; =
        SET PC, error_syntax
    ADD Z, 1
    JSR exec_endst          ; end of statement?
    IFN A, 0                ; if is, finish
        SET PC, error_syntax
    JSR skipspc
    ; rest is assumed to be an expression, just skip it.
    ; FN is the one that cares about it!
    SET Y, POP
    JSR switch_vars         ; time to set flags again
    SET C, [VARLEN]
    JSR VAR_RESERVE
    SET [Y], Z
    SET [Y+2], [VARLEN]
    SET C, [VARLEN]
    SET I, VARNAME
    SET J, Y
    ADD J, 3
:STMT_DEF_VN_COPY
    STI [J], [I]
    SUB C, 1
    IFG C, 0
        SET PC, STMT_DEF_VN_COPY
    JSR switch_code         ; back to code.
    SET PC, STMT_DATA       ; skip until end of statement

:STMT_POKE
    JSR exec_endst          ; end of statement?
    IFN A, 0                ; if is, finish
        SET PC, error_syntax
    JSR exec_expr
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    JSR OP_TO_INT
    SET X, [EXPRSP]
    IFN [X], 1
        SET PC, error_typemis
    IFN [X+2], 0
        SET PC, error_illegalarg
    JSR skipspc
    IFN [Z], 0x002c         ; ","
        SET PC, error_syntax
    ADD Z, 1
    JSR skipspc
    ADD [EXPRSP], 3
    SET [BTMP+8], [X+1]
    JSR exec_endst          ; end of statement?
    IFN A, 0                ; if is, finish
        SET PC, error_syntax
    JSR exec_expr
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    JSR OP_TO_INT
    SET X, [EXPRSP]
    IFN [X], 1
        SET PC, error_typemis
    JSR exec_endst          ; end of statement?
    IFE A, 0                ; if is, finish
        SET PC, error_syntax
    ADD [EXPRSP], 3
    SET A, [BTMP+8]
    SET [A], [X+1]
    SET [readyflag], 1
    SET PC, POP    

:STMT_SYS
    JSR exec_endst          ; end of statement?
    IFN A, 0                ; if is, finish
        SET PC, error_syntax
    JSR exec_expr
    IFN [EXPRERR], 0
        SET PC, exec_expr_err
    JSR OP_TO_INT
    SET X, [EXPRSP]
    IFN [X], 1
        SET PC, error_typemis
    IFN [X+2], 0
        SET PC, error_illegalarg
    SET [BTMP+2], [X+1]
    JSR exec_endst          ; end of statement?
    IFE A, 0                ; if not, finish
        SET PC, error_syntax
    SET PUSH, Z
    SET A, [SYS_REG+0]
    SET B, [SYS_REG+1]
    SET C, [SYS_REG+2]
    SET X, [SYS_REG+3]
    SET Y, [SYS_REG+4]
    SET Z, [SYS_REG+5]
    SET I, [SYS_REG+6]
    SET J, [SYS_REG+7]
    JSR [BTMP+2]
    SET [SYS_REG+0], A
    SET [SYS_REG+1], B
    SET [SYS_REG+2], C
    SET [SYS_REG+3], X
    SET [SYS_REG+4], Y
    SET [SYS_REG+5], Z
    SET [SYS_REG+6], I
    SET [SYS_REG+7], J
    SET Z, POP
    SET [readyflag], 1
    SET PC, POP

; ===========================
; FUNCTIONS
; ===========================

:FUNC_SGN
    JSR skipspc
    IFN [Z], 0x0028         ; "("
        SET PC, exec_expr_syntax
    ADD Z, 1
    JSR exec_expr_raw
    IFN [Z], 0x0029         ; ")"
        SET PC, exec_expr_syntax
    ADD Z, 1
    SET X, [EXPRSP]
    IFE [X], 3              ; string
        SET PC, exec_expr_typemis
    JSR FP0_loadx
    SET A, 1
    IFN [FP0+1], 0
        SET A, 0xFFFF
    IFE [FP0], 0
        SET A, 0
    SUB [EXPRSP], 3
    SET X, [EXPRSP]
    SET [X], 1
    SET [X+1], A
    IFA A, 0
        SET A, 0
    SET [X+2], A
    SET PC, POP

:FUNC_INT
    JSR skipspc
    IFN [Z], 0x0028         ; "("
        SET PC, exec_expr_syntax
    ADD Z, 1
    JSR exec_expr_raw
    IFN [Z], 0x0029         ; ")"
        SET PC, exec_expr_syntax
    ADD Z, 1
    SET X, [EXPRSP]
    IFE [X], 3              ; string
        SET PC, exec_expr_typemis
    IFE [X], 1              ; integer
        SET PC, POP
    JSR FP0_load
    JSR FP0_int32
    ; converts FP0 to unsigned 32-bit int -> A(lo),B(hi)
    ; (FP0 sign is ignored)
    ; if too big to fit, return 0xFFFF,0xFFFF
    IFN [FP0+1], 0
        IFE A, 0
            IFE B, 0x8000
                SET PC, FUNC_INT_N8
    IFL B, 0x8000
        SET PC, FUNC_INT_L8
    IFN [FP0+1], 0
        SET PC, FUNC_INT_N
    JSR FP0_nofrac
    JSR FP0_store
    SET PC, POP

:FUNC_INT_N
    JSR FP0_store
    JSR FP0_frac
    SET [BTMP+8], [FP0+1]
    JSR FP0_load
    JSR FP0_nofrac
    IFE [BTMP+8], 0
        SET PC, FUNC_INT_P
    SET A, FP_c_m1
    JSR FP1_lc
    JSR FP0_add
:FUNC_INT_P
    JSR FP0_store
    SET PC, POP

:FUNC_INT_N8
    SUB [EXPRSP], 3
    SET X, [EXPRSP]
    SET [X], 1
    SET [X+1], A
    SET [X+2], B
    SET PC, POP

:FUNC_INT_L8
    SUB [EXPRSP], 3
    SET X, [EXPRSP]
    SET [X], 1
    SET [X+1], A
    SET [X+2], B
    IFE [FP0+1], 0
        SET PC, POP
    XOR [X+1], 0xFFFF
    XOR [X+2], 0xFFFF
    JSR FP0_frac
    IFN [FP0], 0
        SET PC, POP
    ADD [X+1], 1
    ADX [X+2], 0
    SET PC, POP

:FUNC_ABS
    JSR skipspc
    IFN [Z], 0x0028         ; "("
        SET PC, exec_expr_syntax
    ADD Z, 1
    JSR exec_expr_raw
    IFN [Z], 0x0029         ; ")"
        SET PC, exec_expr_syntax
    ADD Z, 1
    SET X, [EXPRSP]
    IFE [X], 3              ; string
        SET PC, exec_expr_typemis
    IFE [X], 2              ; integer
        SET PC, FUNC_ABS_F
    IFE [X+1], 0            ; -2147483648 couldn't be represented
        IFE [X+2], 0x8000   ; as a positive integer
            SET PC, FUNC_ABS_F
    IFL [X+1], 0x8000
        SET PC, POP
    XOR [X+1], 0xFFFF
    XOR [X+2], 0xFFFF
    ADD [X+1], 1
    ADX [X+2], 0
    SET PC, POP
:FUNC_ABS_F
    JSR FP0_loadx
    IFN [FP0+1], 0
        JSR FP0_neg
    JSR FP0_store
    SET PC, POP

:FUNC_USR
    JSR skipspc
    IFN [Z], 0x0028         ; "("
        SET PC, exec_expr_syntax
    ADD Z, 1
    JSR exec_expr_raw
    IFN [Z], 0x0029         ; ")"
        SET PC, exec_expr_syntax
    ADD Z, 1
    JSR [USRADDR]
    SET PC, POP

:FUNC_FRE
    JSR skipspc
    IFN [Z], 0x0028         ; "("
        SET PC, exec_expr_syntax
    ADD Z, 1
    IFE [Z], 0x0029         ; ")"
        SET PC, FUNC_FRE_NOA
    JSR exec_expr_raw
    IFN [Z], 0x0029         ; ")"
        SET PC, exec_expr_syntax
:FUNC_FRE_NOA
    ADD Z, 1
    JSR freesp
    SUB [EXPRSP], 3
    SET I, [EXPRSP]
    SET [I], 1
    SET [I+1], A
    SET [I+2], B
    SET PC, POP

:FUNC_RND
    JSR skipspc
    IFN [Z], 0x0028         ; "("
        SET PC, exec_expr_syntax
    ADD Z, 1
    IFE [Z], 0x0029         ; ")"
        SET PC, FUNC_RND_NOA
    JSR exec_expr_raw
    IFN [Z], 0x0029         ; ")"
        SET PC, exec_expr_syntax
:FUNC_RND_NOA
    ADD Z, 1
    JSR rnd_calc
    JSR FP0_store
    SET PC, POP

:FUNC_SQR
    JSR skipspc
    IFN [Z], 0x0028         ; "("
        SET PC, exec_expr_syntax
    ADD Z, 1
    JSR exec_expr_raw
    IFN [Z], 0x0029         ; ")"
        SET PC, exec_expr_syntax
    ADD Z, 1
    SET X, [EXPRSP]
    IFE [X], 3
        SET PC, exec_expr_typemis
    JSR FP0_loadx
    JSR FP0_sqrt
    JSR FP0_store
    IFN [FPERROR], 0
        SET PC, exec_expr_val_num_fpe
    SET PC, POP

:FUNC_LOG
    JSR skipspc
    IFN [Z], 0x0028         ; "("
        SET PC, exec_expr_syntax
    ADD Z, 1
    JSR exec_expr_raw
    IFN [Z], 0x0029         ; ")"
        SET PC, exec_expr_syntax
    ADD Z, 1
    SET X, [EXPRSP]
    IFE [X], 3
        SET PC, exec_expr_typemis
    JSR FP0_loadx
    JSR FP0_ln
    JSR FP0_store
    IFN [FPERROR], 0
        SET PC, exec_expr_val_num_fpe
    SET PC, POP

:FUNC_EXP
    JSR skipspc
    IFN [Z], 0x0028         ; "("
        SET PC, exec_expr_syntax
    ADD Z, 1
    JSR exec_expr_raw
    IFN [Z], 0x0029         ; ")"
        SET PC, exec_expr_syntax
    ADD Z, 1
    SET X, [EXPRSP]
    IFE [X], 3
        SET PC, exec_expr_typemis
    JSR FP0_loadx
    JSR FP0_exp
    JSR FP0_store
    IFN [FPERROR], 0
        SET PC, exec_expr_val_num_fpe
    SET PC, POP

:FUNC_SIN
    JSR skipspc
    IFN [Z], 0x0028         ; "("
        SET PC, exec_expr_syntax
    ADD Z, 1
    JSR exec_expr_raw
    IFN [Z], 0x0029         ; ")"
        SET PC, exec_expr_syntax
    ADD Z, 1
    SET X, [EXPRSP]
    IFE [X], 3
        SET PC, exec_expr_typemis
    JSR FP0_loadx
    JSR FP0_sin
    JSR FP0_store
    IFN [FPERROR], 0
        SET PC, exec_expr_val_num_fpe
    SET PC, POP

:FUNC_COS
    JSR skipspc
    IFN [Z], 0x0028         ; "("
        SET PC, exec_expr_syntax
    ADD Z, 1
    JSR exec_expr_raw
    IFN [Z], 0x0029         ; ")"
        SET PC, exec_expr_syntax
    ADD Z, 1
    SET X, [EXPRSP]
    IFE [X], 3
        SET PC, exec_expr_typemis
    JSR FP0_loadx
    JSR FP0_cos
    JSR FP0_store
    IFN [FPERROR], 0
        SET PC, exec_expr_val_num_fpe
    SET PC, POP

:FUNC_TAN
    JSR skipspc
    IFN [Z], 0x0028         ; "("
        SET PC, exec_expr_syntax
    ADD Z, 1
    JSR exec_expr_raw
    IFN [Z], 0x0029         ; ")"
        SET PC, exec_expr_syntax
    ADD Z, 1
    SET X, [EXPRSP]
    IFE [X], 3
        SET PC, exec_expr_typemis
    JSR FP0_loadx
    JSR FP0_tan
    JSR FP0_store
    IFN [FPERROR], 0
        SET PC, exec_expr_val_num_fpe
    SET PC, POP

:FUNC_ATN
    JSR skipspc
    IFN [Z], 0x0028         ; "("
        SET PC, exec_expr_syntax
    ADD Z, 1
    JSR exec_expr_raw
    IFN [Z], 0x0029         ; ")"
        SET PC, exec_expr_syntax
    ADD Z, 1
    SET X, [EXPRSP]
    IFE [X], 3
        SET PC, exec_expr_typemis
    JSR FP0_loadx
    JSR FP0_atan
    JSR FP0_store
    IFN [FPERROR], 0
        SET PC, exec_expr_val_num_fpe
    SET PC, POP

:FUNC_CHRS
    JSR skipspc
    IFN [Z], 0x0028         ; "("
        SET PC, exec_expr_syntax
    ADD Z, 1
    IFE [Z], 0x0029         ; ")"
        SET PC, exec_expr_syntax
    JSR exec_expr_raw
    IFN [Z], 0x0029         ; ")"
        SET PC, exec_expr_syntax
    ADD Z, 1
    SET X, [EXPRSP]
    IFN [X], 1
        SET PC, exec_expr_typemis
    IFN [X+2], 0
        SET PC, exec_expr_illegalarg
    SET A, [X+1]
    AND A, 0x00FF
    ADD [EXPRSP], 3
    SUB [EXPRSP], 3
    SET X, [EXPRSP]
    SET [X], 3
    SET [X+1], 1
    SET [X+2], A
    SET PC, POP

:FUNC_PI
    JSR skipspc
    SET A, FP_c_pi
    JSR FP1_lc
    JSR FP1_T0
    JSR FP0_store
    SET PC, POP

:FUNC_TWOPI
    JSR skipspc
    SET A, FP_c_tau
    JSR FP1_lc
    JSR FP1_T0
    JSR FP0_store
    SET PC, POP

:FUNC_PEEK
    JSR skipspc
    IFN [Z], 0x0028         ; "("
        SET PC, exec_expr_syntax
    ADD Z, 1
    IFE [Z], 0x0029         ; ")"
        SET PC, exec_expr_syntax
    JSR exec_expr_raw
    IFN [Z], 0x0029         ; ")"
        SET PC, exec_expr_syntax
    ADD Z, 1
    JSR OP_TO_INT
    SET X, [EXPRSP]
    IFN [X], 1
        SET PC, exec_expr_typemis
    IFN [X+2], 0
        SET PC, exec_expr_illegalarg
    SET A, [X+1]
    SET [X+1], [A]
    SET [X+2], 0
    SET PC, POP

:FUNC_LEN
    JSR skipspc
    IFN [Z], 0x0028         ; "("
        SET PC, exec_expr_syntax
    ADD Z, 1
    IFE [Z], 0x0029         ; ")"
        SET PC, FUNC_FRE_NOA
    JSR exec_expr_raw
    IFN [Z], 0x0029         ; ")"
        SET PC, exec_expr_syntax
    ADD Z, 1
    SET X, [EXPRSP]
    IFN [X], 3
        SET PC, exec_expr_typemis
    SET A, [X+1]
    ADD [EXPRSP], 2
    ADD [EXPRSP], A
    SUB [EXPRSP], 3
    SET X, [EXPRSP]
    SET [X], 1              ; <int>
    SET [X+1], A
    SET [X+2], 0
    SET PC, POP

; ===========================
; OPERATORS
; ===========================

; Get pointer to second operand at Y (X must have [EXPRSP]!)
:OP_PTR2
    SET Y, X
    IFE [Y], 1
        SET PC, OP_PTR2_INT
    IFE [Y], 2
        SET PC, OP_PTR2_FP
    IFE [Y], 3
        SET PC, OP_PTR2_STR
:OP_PTR2_INT
    ADD Y, 3
    SET PC, POP
:OP_PTR2_FP
    ADD Y, 6
    SET PC, POP
:OP_PTR2_STR
    ADD Y, [Y+1]
    ADD Y, 2
    SET PC, POP

; TODO
:OP_IMOD
:OP_IDIV
    
:OP_NOT
    SET X, [EXPRSP]
    IFN [X], 1
        SET PC, exec_expr_typemis
    XOR [X+1], 0xFFFF
    XOR [X+2], 0xFFFF
    SET PC, POP
    
:OP_XOR
    SET X, [EXPRSP]
    JSR OP_PTR2
    IFN [X], 1
        SET PC, exec_expr_typemis
    IFN [Y], 1
        SET PC, exec_expr_typemis
    ADD [EXPRSP], 3
    XOR [Y+1], [X+1]
    XOR [Y+2], [X+2]
    SET PC, POP

:OP_OR
    SET X, [EXPRSP]
    JSR OP_PTR2
    IFN [X], 1
        SET PC, exec_expr_typemis
    IFN [Y], 1
        SET PC, exec_expr_typemis
    ADD [EXPRSP], 3
    BOR [Y+1], [X+1]
    BOR [Y+2], [X+2]
    SET PC, POP

:OP_AND
    SET X, [EXPRSP]
    JSR OP_PTR2
    IFN [X], 1
        SET PC, exec_expr_typemis
    IFN [Y], 1
        SET PC, exec_expr_typemis
    ADD [EXPRSP], 3
    AND [Y+1], [X+1]
    AND [Y+2], [X+2]
    SET PC, POP

:OP_RES_A
    SUB [EXPRSP], 3
    SET X, [EXPRSP]
    SET [X], 1
    SET [X+1], A
    SET [X+2], A
    SET PC, POP

; String comparison
; Compare at I and J
; String format: [I] length, I+1 starts string
;                same for J
; A = 1 if I greater
;     0 if equal
;    -1 if I less
:strcmp_noB
    IFG [I], [J]
        SET PC, strcmp_noB_gt
    IFL [I], [J]
        SET PC, strcmp_noB_lt
    SET A, [I]
    STI 0, 0                ; increase I and J
:strcmp_noB_loop
    IFE A, 0
        SET PC, strcmp_noB_eq
    IFG [I], [J]
        SET PC, strcmp_noB_gt
    IFL [I], [J]
        SET PC, strcmp_noB_lt
    SUB A, 1
    STI 0, 0                ; increase I and J
    SET PC, strcmp_loop
:strcmp_noB_eq
    SET A, 0
    SET PC, POP
:strcmp_noB_gt
    SET A, 1
    SET PC, POP
:strcmp_noB_lt
    SET A, 0xFFFF           ; -1
    SET PC, POP
    
:OP_EQ
    SET X, [EXPRSP]
    JSR OP_PTR2
    IFE [X], 3
        IFN [Y], 3
            SET PC, exec_expr_typemis
    IFN [X], 3
        IFE [Y], 3
            SET PC, exec_expr_typemis
    SET A, 0xFFFF
    IFE [X], 3
        IFE [Y], 3
            SET PC, OP_EQ_S
    JSR FP1_loadx
    JSR FP0_loadx
    IFN [FP0], [FP1]
        SET A, 0
    IFE A, 0
        SET PC, OP_RES_A
    JSR FP0_sub
    SET [FP0+4], 0
    JSR FP0_nrmz
    SET A, 0xFFFF
    IFN [FP0], 0
        SET A, 0
    SET PC, OP_RES_A
:OP_EQ_S
    SET I, X
    SET J, Y
    STI 0, 0                ; increase I and J
    JSR strcmp_noB
    SHL A, 15               ; -1 0xFFFF -> 0x8000
                            ;  0 0x0000 -> 0x0000
                            ; +1 0x0001 -> 0x8000
    IFN A, 0                ; -1 0x8000 -> 0xFFFF
        BOR A, 0x7FFF       ;  0 0x0000 -> 0x0000
                            ; +1 0x8000 -> 0xFFFF
    XOR A, 0xFFFF           ; -1 0xFFFF -> 0x0000
        BOR A, 0x7FFF       ;  0 0x0000 -> 0xFFFF
                            ; +1 0xFFFF -> 0x0000
    SET PC, OP_RES_A

:OP_LT
    SET X, [EXPRSP]
    JSR OP_PTR2
    IFE [X], 3
        IFN [Y], 3
            SET PC, exec_expr_typemis
    IFN [X], 3
        IFE [Y], 3
            SET PC, exec_expr_typemis
    SET A, 0xFFFF
    IFE [X], 3
        IFE [Y], 3
            SET PC, OP_LT_S
    JSR FP1_loadx
    JSR FP0_loadx
    JSR FP0_sub
    SET [FP0+4], 0
    JSR FP0_nrmz
    SET A, 0xFFFF
    IFE [FP0], 0
        SET A, 0
    IFE [FP0+1], 0
        SET A, 0
    SET PC, OP_RES_A
:OP_LT_S
    SET I, X
    SET J, Y
    STI 0, 0                ; increase I and J
    JSR strcmp_noB
    SHR A, 1                ; -1 0xFFFF -> 0x7FFF
                            ;  0 0x0000 -> 0x0000
                            ; +1 0x0001 -> 0x0000
    IFN A, 0                ; -1 0x7FFF -> 0xFFFF
        BOR A, 0x8000       ;  0 0x0000 -> 0x0000
                            ; +1 0x0000 -> 0x0000
    SET PC, OP_RES_A

:OP_LE
    SET X, [EXPRSP]
    JSR OP_PTR2
    IFE [X], 3
        IFN [Y], 3
            SET PC, exec_expr_typemis
    IFN [X], 3
        IFE [Y], 3
            SET PC, exec_expr_typemis
    SET A, 0xFFFF
    IFE [X], 3
        IFE [Y], 3
            SET PC, OP_LE_S
    JSR FP1_loadx
    JSR FP0_loadx
    JSR FP0_sub
    SET [FP0+4], 0
    JSR FP0_nrmz
    SET A, 0xFFFF
    IFE [FP0+1], 0
        SET A, 0
    IFE [FP0], 0
        SET A, 0xFFFF
    SET PC, OP_RES_A
:OP_LE_S
    SET I, X
    SET J, Y
    STI 0, 0                ; increase I and J
    JSR strcmp_noB
    IFU A, 0                ; -1 0xFFFF -> 0x0000
        SET A, 0            ;  0 0x0000 -> 0x0000
                            ; +1 0x0001 -> 0x0001
    IFN A, 0                ; -1 0x0000 -> 0x0000
        SET A, 0xFFFF       ;  0 0x0000 -> 0x0000
                            ; +1 0x0001 -> 0xFFFF
    XOR A, 0xFFFF           ; -1 0x0000 -> 0xFFFF
                            ;  0 0x0000 -> 0xFFFF
                            ; +1 0x0001 -> 0x0000
    SET PC, OP_RES_A

:OP_NE
    JSR OP_EQ
    JSR OP_NOT
    SET PC, POP

:OP_GE
    JSR OP_LT
    JSR OP_NOT
    SET PC, POP

:OP_GT
    JSR OP_LE
    JSR OP_NOT
    SET PC, POP

:OP_NEG
    SET X, [EXPRSP]
    IFE [X], 3
        SET PC, exec_expr_typemis
    IFE [X], 1
        SET PC, OP_NEG_INT
:OP_NEG_FP
    JSR FP0_loadx
    JSR FP0_neg
    JSR FP0_store
    SET PC, POP

:OP_NEG_INT
    IFE [X+1], 0
        IFE [X+2], 0x8000
            SET PC, OP_NEG_FP
    XOR [X+1], 0xFFFF
    XOR [X+2], 0xFFFF
    ADD [X+1], 1
    ADX [X+2], 0
    SET PC, POP

:OP_SUB
    JSR OP_NEG
    IFN [EXPRERR], 0
        SET PC, POP
:OP_ADD
    SET X, [EXPRSP]
    JSR OP_PTR2
    IFE [Y], 3
        IFE [X], 3
            SET PC, OP_ADD_SC
    IFE [Y], 3
        SET PC, OP_ADD_SY
    IFE [X], 3
        SET PC, OP_ADD_SX
    IFE [Y], 1
        IFE [X], 1
            SET PC, OP_ADD_INT

:OP_ADD_FP
    JSR FP1_loadx
    JSR FP0_loadx
    JSR FP0_add
    JSR FP0_store
    IFN [FPERROR], 0
        SET PC, exec_expr_val_num_fpe
    SET PC, POP

:OP_ADD_INT
    SET A, [X+2]
    XOR A, [Y+2]
    IFB A, 0x8000
        SET PC, OP_ADD_INT_OK
    SET [X+0xFFFE], [X+1]
    SET [X+0xFFFF], [X+2]
    ADD [X+0xFFFE], [Y+1]
    ADX [X+0xFFFF], [Y+2]
    SET A, [X+2]
    XOR A, [X+0xFFFF]
    IFB A, 0x8000
        SET PC, OP_ADD_FP
:OP_ADD_INT_OK
    ADD [Y+1], [X+1]
    ADX [Y+2], [X+2]
    ADD [EXPRSP], 3
    SET PC, POP

:OP_ADD_SX
    ; copy string X to LINEBUF,STR1,STR2,STR3
    SET [BTMP], [X+1]
    SET C, [X+1]
    SET I, X
    ADD I, 2
    SET J, LINEBUF
    JSR copy_block_c
    ADD [EXPRSP], [BTMP]
    ADD [EXPRSP], 2
    JSR OP_TO_STR       ; conv Y -> string
    SET Y, [EXPRSP]
    SUB [EXPRSP], 2
    SUB [EXPRSP], [BTMP]
    IFL [EXPRSP], EXPR_STACK_LM
        SET PC, error_strlen
    SET X, [EXPRSP]
    SET [X], 3
    SET [X+1], [BTMP]
    SET C, [BTMP]
    SET I, LINEBUF
    SET J, X
    ADD J, 2
    JSR copy_block_c
:OP_ADD_SY
    JSR OP_TO_STR       ; conv X -> string
    SET X, [EXPRSP]
:OP_ADD_SC
    ; copy string X to LINEBUF,STR1,STR2,STR3
    SET [BTMP], [X+1]
    SET [BTMP+1], [Y+1]
    SET C, [X+1]
    SET I, X
    ADD I, 2
    SET J, LINEBUF
    JSR copy_block_c
    ; copy string Y to X+4
    SET C, [BTMP+1]
    SET I, Y
    ADD I, 2
    SET J, X
    ADD J, 4
    JSR copy_block_c
    ; append 
    SET C, [BTMP]
    SET I, LINEBUF
    SET J, X
    ADD J, 4
    ADD J, [BTMP+1]
    JSR copy_block_c
    ADD [EXPRSP], 2
    SET X, [EXPRSP]
    SET [X], 3
    SET [X+1], [BTMP]
    ADD [X+1], [BTMP+1]
    SET PC, POP

:OP_MUL
    SET X, [EXPRSP]
    JSR OP_PTR2
    IFE [Y], 3
        SET PC, exec_expr_typemis
    IFE [X], 3
        SET PC, exec_expr_typemis
    IFN [Y], 1
        SET PC, OP_MUL_FP
    IFN [X], 1
        SET PC, OP_MUL_FP
:OP_MUL_INT
    IFU [X+2], 0
        IFU [Y+2], 0
            SET PC, OP_MUL_NEG_2
    IFU [X+2], 0
        SET PC, OP_MUL_NEG_X
    IFU [Y+2], 0
        SET PC, OP_MUL_NEG_Y
    IFN [Y+2], 0
        SET PC, OP_MUL_FP
    IFN [X+2], 0
        SET PC, OP_MUL_FP
    ADD [EXPRSP], 3
    MUL [Y+1], [X+1]
    ADX [Y+2], 0
    SET PC, POP
:OP_MUL_FP
    JSR FP1_loadx
    JSR FP0_loadx
    JSR FP0_mul
    JSR FP0_store
    IFN [FPERROR], 0
        SET PC, exec_expr_val_num_fpe
    SET PC, POP

:OP_MUL_NEG_X
    XOR [X+1], 0xFFFF
    XOR [X+2], 0xFFFF
    ADD [X+1], 1
    ADX [X+2], 0
    SET PC, OP_MUL_NEG_1
:OP_MUL_NEG_Y
    XOR [Y+1], 0xFFFF
    XOR [Y+2], 0xFFFF
    ADD [Y+1], 1
    ADX [Y+2], 0
:OP_MUL_NEG_1  
    JSR OP_MUL_INT
    XOR [Y+1], 0xFFFF
    XOR [Y+2], 0xFFFF
    ADD [Y+1], 1
    ADX [Y+2], 0
    SET PC, POP

:OP_MUL_NEG_2
    XOR [X+1], 0xFFFF
    XOR [X+2], 0xFFFF
    ADD [X+1], 1
    ADX [X+2], 0
    XOR [Y+1], 0xFFFF
    XOR [Y+2], 0xFFFF
    ADD [Y+1], 1
    ADX [Y+2], 0
    SET PC, OP_MUL_INT

:OP_DIV
    SET X, [EXPRSP]
    JSR OP_PTR2
    IFE [X], 3
        SET PC, exec_expr_typemis
    IFE [Y], 3
        SET PC, exec_expr_typemis
    JSR FP1_loadx
    JSR FP0_loadx
    JSR FP0_div
    IFN [FPERROR], 0
        SET PC, exec_expr_val_num_fpe
    JSR FP0_store
    SET PC, POP

:OP_POW
    SET X, [EXPRSP]
    JSR OP_PTR2
    IFE [X], 3
        SET PC, exec_expr_typemis
    IFE [Y], 3
        SET PC, exec_expr_typemis
    JSR FP1_loadx
    JSR FP0_loadx
    JSR FP0_pow
    IFN [FPERROR], 0
        SET PC, exec_expr_val_num_fpe
    JSR FP0_store
    SET PC, POP

:OP_TO_INT
    SET A, [EXPRSP]
    IFE [A], 3
        SET PC, POP
    IFE [A], 1
        SET PC, POP
    JSR FP0_load
    JSR FP0_int32_adv
    IFN [FPERROR], 0
        SET PC, exec_expr_typemis
    SUB [EXPRSP], 3
    SET [X], 1
    SET [X+1], [FTMP]
    SET [X+2], [FTMP+1]
    SET PC, switch_code

:OP_TO_STR
    SET A, [EXPRSP]
    IFE [A], 3
        SET PC, POP
    IFE [A], 1
        SET PC, OP_TO_STR_INT
:OP_TO_STR_FP               ; [A] = 2
    ADD [EXPRSP], 6
    SET [FP0], [A+1]
    SET [FP0+1], [A+2]
    SET [FP0+2], [A+3]
    SET [FP0+3], [A+4]
    SET [FP0+4], [A+5]
    JSR FP0_str
    SET PC, OP_TO_STR_STR3
:OP_TO_STR_INT
    ADD [EXPRSP], 3
    SET B, [A+2]
    SET A, [A+1]
    JSR int_str
:OP_TO_STR_STR3
    SET C, 0
    SET I, STR3
:OP_TO_STR_STR3_COUNT
    IFE [I], 0
        SET PC, OP_TO_STR_STR3_COUNT_END
    ADD C, 1
    ADD I, 1
    SET PC, OP_TO_STR_STR3_COUNT
:OP_TO_STR_STR3_COUNT_END
    SUB [EXPRSP], 2
    SUB [EXPRSP], C
    IFL [EXPRSP], EXPR_STACK_LM
        SET PC, error_strlen
    SET A, [EXPRSP]
    SET [A], 3 ; string 
    SET [A+1], C
    SET I, STR3
    SET J, [EXPRSP]
    ADD J, 2
:OP_TO_STR3_STR3_LOOP
    IFE C, 0
        SET PC, OP_TO_STR_STR3_LOOP_END
    STI [J], [I]
    SUB C, 1
    SET PC, OP_TO_STR3_STR3_LOOP
:OP_TO_STR_STR3_LOOP_END
    SET PC, POP

; ===========================
; NUMBER & FLOATING-POINT
; ===========================

:rnd_update_seed
    SET [FTMP], [RND_SEED]
    SET [FTMP+1], [RND_SEED+1]
    SHL [RND_SEED], 10
    ROL [RND_SEED+1], 10
    ADD [RND_SEED], [FTMP]
    ADX [RND_SEED+1], [FTMP+1]
    ADD [RND_SEED], 0xB721
    ADX [RND_SEED+1], 0x073E
    SET PC, POP

; Compute a random number to FP0
:rnd_calc
    SET [RND_CALLED], 0xFFFF
    JSR rnd_update_seed
    SET [FP0], 0x0080
    SET [FP0+1], 0
    JSR rnd_update_seed
    SET [FP0+2], [RND_SEED+1]
    JSR rnd_update_seed
    SET [FP0+3], [RND_SEED+1]
    JSR rnd_update_seed
    SET [FP0+4], [RND_SEED+1]
    SET PC, FP0_nrmz

:FP0_T1
    SET A, FP0
    SET B, FP1
    SET PC, FP_CPY
:FP1_T0
    SET A, FP1
    SET B, FP0
; FP_B = FP_A (A = FP0, B = FP1 -> FP0->FP1)
:FP_CPY
    SET [B], [A]
    SET [B+1], [A+1]
    SET [B+2], [A+2]
    SET [B+3], [A+3]
    SET [B+4], [A+4]
    SET PC, POP

; shift mantissa in A right by B bits
; affected registers: A, B
:FP_msr
    IFE B, 0
        SET PC, POP
    SHR [2+A], 1
    ROR [3+A], 1
    ROR [4+A], 1
    SUB B, 1
    SET PC, FP_msr

; convert storage FP @ I to computation FP @ J
; affected registers: A, I, J
:FP_unpack
    SET [J], [I]
    SHR [J], 8
    SET A, [I]
    SHR A, 7
    AND A, 1
    SET [J+1], 0
    SUB [J+1], A
    SET [J+2], [I]
    SET [J+3], [I+1]
    SET [J+4], [I+2]
    SHL [J+4], 9
    ROL [J+3], 9
    ROL [J+2], 9
    SET PC, POP

; convert computation FP @ J to storage FP @ I
; affected registers: A, I, J
:FP_pack
    SET A, [J]
    SHL A, 8
    SET [I], A
    SET A, [J+1]
    AND A, 0x80
    XOR [I], A
    SET [I+1], [J+2]
    SET [I+2], [J+3]
    SET [I+3], [J+4]
    SHL [I+3], 7
    ROL [I+2], 7
    ROL [I+1], 7
    BOR [I], EX
    SET A, [I+3]
    SET [I+3], 0
    IFC A, 0x8000
        SET PC, POP
    SET A, [I]
    AND A, 0xFF00
    IFE A, 0xFF00
        SET PC, POP
    ADD [I+2], 1
    ADX [I+1], 0
    IFE EX, 0
        SET PC, POP
    SHR [I+1], 1
    ROR [I+2], 1
    ADD [I], 0x0100
    SET PC, POP

; load FP0 from expression stack
; also supports integers
:FP0_loadx
    SET A, [EXPRSP]
    IFE [A], 1
        SET PC, FP0_loadx_int
    IFN [A], 2
        SET PC, POP
    SET PC, FP0_load
:FP0_loadx_int
    IFU [A+2], 0
        SET PC, FP0_loadx_int_neg
:FP0_loadx_int_pos
    SET [FP0], 0x00A0
    SET [FP0+1], 0x0000
    SET [FP0+2], [A+2]
    SET [FP0+3], [A+1]
    SET [FP0+4], 0
    ADD [EXPRSP], 3
    SET PC, FP0_nrm
:FP0_loadx_int_neg
    XOR [A+1], 0xFFFF
    XOR [A+2], 0xFFFF
    ADD [A+1], 1
    ADX [A+2], 0
    JSR FP0_loadx_int_pos
    SET PC, FP0_neg

; load FP1 from expression stack
; also supports integers
:FP1_loadx
    SET A, [EXPRSP]
    IFE [A], 1
        SET PC, FP1_loadx_int
    IFN [A], 2
        SET PC, POP
    SET PC, FP1_load
:FP1_loadx_int
    IFU [A+2], 0
        SET PC, FP1_loadx_int_neg
:FP1_loadx_int_pos
    SET [FP1], 0x00A0
    SET [FP1+1], 0x0000
    SET [FP1+2], [A+2]
    SET [FP1+3], [A+1]
    SET [FP1+4], 0
    ADD [EXPRSP], 3
    SET PC, FP1_nrm
:FP1_loadx_int_neg
    XOR [A+1], 0xFFFF
    XOR [A+2], 0xFFFF
    ADD [A+1], 1
    ADX [A+2], 0
    JSR FP1_loadx_int_pos
    SET PC, FP1_neg

; load FP2 from expression stack
; also supports integers
:FP2_loadx
    SET A, [EXPRSP]
    IFE [A], 1
        SET PC, FP2_loadx_int
    IFN [A], 2
        SET PC, POP
    SET PC, FP2_load
:FP2_loadx_int
    IFU [A+2], 0
        SET PC, FP2_loadx_int_neg
:FP2_loadx_int_pos
    SET [FP2], 0x00A0
    SET [FP2+1], 0x0000
    SET [FP2+2], [A+2]
    SET [FP2+3], [A+1]
    SET [FP2+4], 0
    ADD [EXPRSP], 3
    SET PC, FP2_nrm
:FP2_loadx_int_neg
    XOR [A+1], 0xFFFF
    XOR [A+2], 0xFFFF
    ADD [A+1], 1
    ADX [A+2], 0
    JSR FP2_loadx_int_pos
    SET PC, FP2_neg

; load FP0 from expression stack
:FP0_load
    SET A, [EXPRSP]
    IFN [A], 2
        SET PC, POP
    SET [FP0], [A+1]
    SET [FP0+1], [A+2]
    SET [FP0+2], [A+3]
    SET [FP0+3], [A+4]
    SET [FP0+4], [A+5]
    ADD [EXPRSP], 6
    SET PC, POP

; load FP1 from expression stack
:FP1_load
    SET A, [EXPRSP]
    IFN [A], 2
        SET PC, POP
    SET [FP1], [A+1]
    SET [FP1+1], [A+2]
    SET [FP1+2], [A+3]
    SET [FP1+3], [A+4]
    SET [FP1+4], [A+5]
    ADD [EXPRSP], 6
    SET PC, POP

; load FP2 from expression stack
:FP2_load
    SET A, [EXPRSP]
    IFN [A], 2
        SET PC, POP
    SET [FP2], [A+1]
    SET [FP2+1], [A+2]
    SET [FP2+2], [A+3]
    SET [FP2+3], [A+4]
    SET [FP2+4], [A+5]
    ADD [EXPRSP], 6
    SET PC, POP

; store FP0 to expression stack
:FP0_store
    SUB [EXPRSP], 6
    SET A, [EXPRSP]
    SET [A], 2 ; float
    SET [A+1], [FP0]
    SET [A+2], [FP0+1]
    SET [A+3], [FP0+2]
    SET [A+4], [FP0+3]
    SET [A+5], [FP0+4]
    SET PC, POP

; store FP1 to expression stack
:FP1_store
    SUB [EXPRSP], 6
    SET A, [EXPRSP]
    SET [A], 2 ; float
    SET [A+1], [FP1]
    SET [A+2], [FP1+1]
    SET [A+3], [FP1+2]
    SET [A+4], [FP1+3]
    SET [A+5], [FP1+4]
    SET PC, POP

; store FP2 to expression stack
:FP2_store
    SUB [EXPRSP], 6
    SET A, [EXPRSP]
    SET [A], 2 ; float
    SET [A+1], [FP2]
    SET [A+2], [FP2+1]
    SET [A+3], [FP2+2]
    SET [A+4], [FP2+3]
    SET [A+5], [FP2+4]
    SET PC, POP
    
:FP_rst             ; reset
    SET [FPERROR], 0
    SET PC, POP
:FP_ovf             ; overflow!
    SET [FPERROR], 1
    SET PC, POP
:FP_d0              ; division by 0
    SET [FPERROR], 2
    SET PC, POP
:FP_dom             ; math/range/domain error
    SET [FPERROR], 3
    SET PC, POP

:FP1_nadd
    XOR [FP1+1], 0xFFFF
; FP0 = FP0 + FP1
; FP1 not modified
; affected registers: A
:FP0_add
    IFU [FP1], 1
        SET PC, POP
    IFU [FP0], 1
        SET PC, FP1_T0        
    SET A, [FP0+1]
    XOR A, [FP1+1]
    IFN A, 0
        SET PC, FP1_nsub
    SET [FPT+2], [FP1+2]
    SET [FPT+3], [FP1+3]
    SET [FPT+4], [FP1+4]
    IFE [FP0], [FP1]
        SET PC, FP0_add_d
    IFG [FP0], [FP1]
        SET PC, FP0_add_g0
:FP0_add_g1
    SET B, [FP1]
    SUB B, [FP0]
    SET A, FP0
    SET [FP0], [FP1]
    JSR FP_msr
    SET PC, FP0_add_d
:FP0_add_g0
    SET B, [FP0]
    SUB B, [FP1]
    SET A, FPT
    JSR FP_msr
:FP0_add_d
    ADD [FP0+4], [FPT+4]
    ADX [FP0+3], [FPT+3]
    ADX [FP0+2], [FPT+2]
    IFE EX, 0
        SET PC, FP0_nrm
    SET A, EX
    SHR [FP0+2], 1
    ROR [FP0+3], 1
    ROR [FP0+4], 1
    SHL A, 15
    BOR [FP0+2], A
    ADD [FP0], 1
    IFG [FP0], 0xFF
        SET PC, FP_ovf
    SET PC, FP0_nrm

; FP0 = -FP1
:FP0_0sub
    JSR FP1_T0
; FP0 = -FP0
:FP0_neg
    XOR [FP0+1], 0xFFFF
    SET PC, POP

; FP1 = -FP1
:FP1_neg
    XOR [FP1+1], 0xFFFF
    SET PC, POP

; FP2 = -FP2
:FP2_neg
    XOR [FP2+1], 0xFFFF
    SET PC, POP

:FP1_nsub
    XOR [FP1+1], 0xFFFF
; FP0 = FP0 - FP1
; FP1 not modified
; affected registers: A
:FP0_sub
    IFU [FP1], 1
        SET PC, POP
    IFU [FP0], 1
        SET PC, FP0_0sub
    SET A, [FP0+1]
    XOR A, [FP1+1]
    IFN A, 0
        SET PC, FP1_nadd
    SET [FPT+2], [FP1+2]
    SET [FPT+3], [FP1+3]
    SET [FPT+4], [FP1+4]
    IFE [FP0], [FP1]
        SET PC, FP0_sub_d
    IFG [FP0], [FP1]
        SET PC, FP0_sub_g0
:FP0_sub_g1
    SET B, [FP1]
    SUB B, [FP0]
    SET A, FP0
    SET [FP0], [FP1]
    JSR FP_msr
    SET PC, FP0_sub_d
:FP0_sub_g0
    SET B, [FP0]
    SUB B, [FP1]
    SET A, FPT
    JSR FP_msr
:FP0_sub_d
    IFG [FP0+2], [FPT+2]
        SET PC, FP0_sub_ov
    IFL [FP0+2], [FPT+2]
        SET PC, FP0_sub_rv
    IFG [FP0+3], [FPT+3]
        SET PC, FP0_sub_ov
    IFL [FP0+3], [FPT+3]
        SET PC, FP0_sub_rv
    IFG [FP0+4], [FPT+4]
        SET PC, FP0_sub_ov
    IFL [FP0+4], [FPT+4]
        SET PC, FP0_sub_rv
    ; numbers equal, store 0
; FP0 = 0.0
:FP0_LD0    
    SET [FP0], 0
    SET [FP0+1], 0
    SET [FP0+2], 0
    SET [FP0+3], 0
    SET [FP0+4], 0
    SET PC, POP
:FP0_sub_ov
    SUB [FP0+4], [FPT+4]
    SBX [FP0+3], [FPT+3]
    SBX [FP0+2], [FPT+2]
    SET PC, FP0_nrm
:FP0_sub_rv
    SUB [FPT+4], [FP0+4]
    SBX [FPT+3], [FP0+3]
    SBX [FPT+2], [FP0+2]
    SET [FP0+2], [FPT+2]
    SET [FP0+3], [FPT+3]
    SET [FP0+4], [FPT+4]
    JSR FP0_neg
    SET PC, FP0_nrm

; FP1 = 0.0
:FP1_LD0
    SET [FP1], 0
    SET [FP1+1], 0
    SET [FP1+2], 0
    SET [FP1+3], 0
    SET [FP1+4], 0
    SET PC, POP

; FP2 = 0.0
:FP2_LD0
    SET [FP2], 0
    SET [FP2+1], 0
    SET [FP2+2], 0
    SET [FP2+3], 0
    SET [FP2+4], 0
    SET PC, POP

; normalize FP0, or set it to 0 if mantissa is
:FP0_nrmz
    IFE [FP0+2], 0
        IFE [FP0+3], 0
            IFE [FP0+4], 0
                SET PC, FP0_LD0

; normalize FP0
; shift mantissa left, until top bit set
; decrease exponent, if hits 0, set all to 0
:FP0_nrm
    IFB [FP0+2], 0x8000
        SET PC, POP
    SHL [FP0+4], 1
    ROL [FP0+3], 1
    ROL [FP0+2], 1
    SUB [FP0], 1
    IFE [FP0], 0
        SET PC, FP0_LD0
    SET PC, FP0_nrm

; normalize FP1, or set it to 0 if mantissa is
:FP1_nrmz
    IFE [FP1+2], 0
        IFE [FP1+3], 0
            IFE [FP1+4], 0
                SET PC, FP1_LD0

; normalize FP1
; shift mantissa left, until top bit set
; decrease exponent, if hits 0, set all to 0
:FP1_nrm
    IFB [FP1+2], 0x8000
        SET PC, POP
    SHL [FP1+4], 1
    ROL [FP1+3], 1
    ROL [FP1+2], 1
    SUB [FP1], 1
    IFE [FP1], 0
        SET PC, FP1_LD0
    SET PC, FP1_nrm

; normalize FP2
; shift mantissa left, until top bit set
; decrease exponent, if hits 0, set all to 0
:FP2_nrm
    IFB [FP2+2], 0x8000
        SET PC, POP
    SHL [FP2+4], 1
    ROL [FP2+3], 1
    ROL [FP2+2], 1
    SUB [FP2], 1
    IFE [FP2], 0
        SET PC, FP2_LD0
    SET PC, FP2_nrm

; FP0 = FP0 * FP1
; FP1 not modified
; affected registers: A
:FP0_mul
    IFU [FP1], 1
        SET PC, FP0_LD0
    IFU [FP0], 1
        SET PC, FP0_LD0
    ADD [FP0], [FP1]
    SUB [FP0], 0x80
    IFU [FP0], 0x01
        SET PC, FP0_LD0
    IFG [FP0], 0xFF
        SET PC, FP_ovf
    XOR [FP0+1], [FP1+1]  
    
; [FTMP+8] = [FP0+2] * [FP1+2]
;   96b       48b       48b
    SET A, [FP1+4]
    MUL A, [FP0+4]
    SET [FTMP+12], EX
    SET [FTMP+13], A
    SET A, [FP1+4]
    MUL A, [FP0+3]
    SET [FTMP+11], EX
    ADD [FTMP+12], A
    ADX [FTMP+11], 0
    SET A, [FP1+3]
    MUL A, [FP0+4]
    ADD [FTMP+11], EX
    SET [FTMP+10], EX
    ADD [FTMP+12], A
    ADX [FTMP+11], 0
    SET A, [FP1+2]
    MUL A, [FP0+4]
    ADD [FTMP+10], EX
    SET [FTMP+9], EX
    ADD [FTMP+11], A
    ADX [FTMP+10], 0
    SET A, [FP1+4]
    MUL A, [FP0+2]
    ADD [FTMP+10], EX
    ADX [FTMP+9], 0
    ADD [FTMP+11], A
    ADX [FTMP+10], 0
    SET A, [FP1+3]
    MUL A, [FP0+3]
    ADD [FTMP+10], EX
    ADX [FTMP+9], 0
    ADD [FTMP+11], A
    ADX [FTMP+10], 0
    SET A, [FP1+2]
    MUL A, [FP0+3]
    ADD [FTMP+9], EX
    SET [FTMP+8], EX
    ADD [FTMP+10], A
    ADX [FTMP+9], 0
    SET A, [FP1+3]
    MUL A, [FP0+2]
    ADD [FTMP+9], EX
    ADX [FTMP+8], 0
    ADD [FTMP+10], A
    ADX [FTMP+9], 0
    SET A, [FP1+2]
    MUL A, [FP0+2]
    ADD [FTMP+8], EX
    ADD [FTMP+9], A
    ADX [FTMP+8], 0

    SET [FP0+2], [FTMP+8]
    SET [FP0+3], [FTMP+9]
    SET [FP0+4], [FTMP+10]
    SET PC, FP0_nrm

; load constant at A to B
:FP_lc
    SET [B], [A]
    SET [B+1], [A+1]
    SET [B+2], [A+2]
    SET [B+3], [A+3]
    SET [B+4], [A+4]
    SET PC, POP

; load constant at A to FP1
:FP1_lc
    SET [FP1], [A]
    SET [FP1+1], [A+1]
    SET [FP1+2], [A+2]
    SET [FP1+3], [A+3]
    SET [FP1+4], [A+4]
    SET PC, POP

:FP0_divR0
    DAT 0, 0, 0, 0, 0
:FP0_divR1
    DAT 0, 0, 0, 0, 0
:FP0_divR2
    DAT 0, 0, 0, 0, 0
:FP0_divR3
    DAT 0, 0, 0, 0, 0
:FP0_div_cou
    DAT 0
; FP0 = FP0 / FP1
; FP1 not modified (saved)
; affected registers: A, I, J
:FP0_div
    IFU [FP1], 1
        SET PC, FP_d0
    IFU [FP0], 1
        SET PC, FP0_LD0
    SET A, [FP0]
    SUB A, [FP1]
    ADD A, 0x80
    IFU A, 0x01
        SET PC, FP0_LD0
    IFG A, 0xFF
        SET PC, FP_ovf
    XOR [FP0+1], [FP1+1]  
    SET [FP0_divR3], [FP1]
    SET [FP0_divR3+1], [FP1+1]
    SET [FP0_divR3+2], [FP1+2]
    SET [FP0_divR3+3], [FP1+3]
    SET [FP0_divR3+4], [FP1+4]
    SET [FP0_divR0], A
    SET [FP0_divR0+1], [FP0+1]
    SET [FP0_divR0+2], [FP0+2]
    SET [FP0_divR0+3], [FP0+3]
    SET [FP0_divR0+4], [FP0+4]
    SET [FP0], 0x80
    SET [FP0+1], 0x00
    SET [FP0+2], [FP1+2]
    SET [FP0+3], [FP1+3]
    SET [FP0+4], [FP1+4]
    JSR FP0_neg
    SET [FP1], 0x81
    SET [FP1+1], 0
    SET [FP1+2], 0x8000
    SET [FP1+3], 0
    SET [FP1+4], 0
    JSR FP0_add
    IFN [FPERROR], 0
        SET PC, POP
    SET [FP0_divR1], [FP0]
    SET [FP0_divR1+1], [FP0+1]
    SET [FP0_divR1+2], [FP0+2]
    SET [FP0_divR1+3], [FP0+3]
    SET [FP0_divR1+4], [FP0+4]
    SET [FP0_div_cou], 5
:FP0_div_loop
    SET [FP1], 0x81
    SET [FP1+1], 0
    SET [FP1+2], 0x8000
    SET [FP1+3], 0
    SET [FP1+4], 0
    JSR FP0_add
    SET [FP1], [FP0_divR0]
    SET [FP1+1], [FP0_divR0+1]
    SET [FP1+2], [FP0_divR0+2]
    SET [FP1+3], [FP0_divR0+3]
    SET [FP1+4], [FP0_divR0+4]
    JSR FP0_mul
    IFN [FPERROR], 0
        SET PC, POP
    SET [FP0_divR0], [FP0]
    SET [FP0_divR0+1], [FP0+1]
    SET [FP0_divR0+2], [FP0+2]
    SET [FP0_divR0+3], [FP0+3]
    SET [FP0_divR0+4], [FP0+4]
    ; FP0_divR1 = FP0_divR1 * FP0_divR1
    ADD [FP0_divR1], [FP0_divR1]
    SUB [FP0_divR1], 0x80
    SET A, [FP0_divR1+4]
    MUL A, [FP0_divR1+4]
    SET [FTMP+12], EX
    SET [FTMP+13], A
    SET A, [FP0_divR1+4]
    MUL A, [FP0_divR1+3]
    SET [FTMP+11], EX
    ADD [FTMP+12], A
    ADX [FTMP+11], 0
    SET A, [FP0_divR1+3]
    MUL A, [FP0_divR1+4]
    ADD [FTMP+11], EX
    SET [FTMP+10], EX
    ADD [FTMP+12], A
    ADX [FTMP+11], 0
    SET A, [FP0_divR1+2]
    MUL A, [FP0_divR1+4]
    ADD [FTMP+10], EX
    SET [FTMP+9], EX
    ADD [FTMP+11], A
    ADX [FTMP+10], 0
    SET A, [FP0_divR1+4]
    MUL A, [FP0_divR1+2]
    ADD [FTMP+10], EX
    ADX [FTMP+9], 0
    ADD [FTMP+11], A
    ADX [FTMP+10], 0
    SET A, [FP0_divR1+3]
    MUL A, [FP0_divR1+3]
    ADD [FTMP+10], EX
    ADX [FTMP+9], 0
    ADD [FTMP+11], A
    ADX [FTMP+10], 0
    SET A, [FP0_divR1+2]
    MUL A, [FP0_divR1+3]
    ADD [FTMP+9], EX
    SET [FTMP+8], EX
    ADD [FTMP+10], A
    ADX [FTMP+9], 0
    SET A, [FP0_divR1+3]
    MUL A, [FP0_divR1+2]
    ADD [FTMP+9], EX
    ADX [FTMP+8], 0
    ADD [FTMP+10], A
    ADX [FTMP+9], 0
    SET A, [FP0_divR1+2]
    MUL A, [FP0_divR1+2]
    ADD [FTMP+8], EX
    ADD [FTMP+9], A
    ADX [FTMP+8], 0
    SET [FP0_divR1+2], [FTMP+8]
    SET [FP0_divR1+3], [FTMP+9]
    SET [FP0_divR1+4], [FTMP+10]
    SET [FP0], [FP0_divR1]
    SET [FP0+1], [FP0_divR1+1]
    SET [FP0+2], [FP0_divR1+2]
    SET [FP0+3], [FP0_divR1+3]
    SET [FP0+4], [FP0_divR1+4]
    SUB [FP0_div_cou], 1
    IFN [FP0_div_cou], 0
        SET PC, FP0_div_loop

    SET [FP0], [FP0_divR0]
    SET [FP0+1], [FP0_divR0+1]
    SET [FP0+2], [FP0_divR0+2]
    SET [FP0+3], [FP0_divR0+3]
    SET [FP0+4], [FP0_divR0+4]
    SET [FP1], [FP0_divR3]
    SET [FP1+1], [FP0_divR3+1]
    SET [FP1+2], [FP0_divR3+2]
    SET [FP1+3], [FP0_divR3+3]
    SET [FP1+4], [FP0_divR3+4]
    SET PC, FP0_nrm
    
; FP0 = FP0 / 2
:FP0_div2  
    SUB [FP0], 1
    IFU [FP0], 1
        SET PC, FP0_LD0
    SET PC, POP
    
; FP0 = FP0 * 2
:FP0_mul2  
    ADD [FP0], 1
    IFE [FP0], 0
        SET PC, POP
    IFG [FP0], 0xFF
        SET PC, FP_ovf
    SET PC, POP

:FP0_sqrtR0
    DAT 0x0080, 0, 0, 0, 0
:FP0_sqrt_exp  
    DAT 0
:FP0_sqrt_odd
    DAT 0
:FP0_sqrt_cou
    DAT 0
; FP0 = SQR(FP0)
; FP1 is destroyed!
; affected registers: A, I, J
:FP0_sqrt
    SET [FP0_sqrt_odd], 0
    IFE [FP0], 0
        SET PC, FP0_LD0
    IFN [FP0+1], 0
        SET PC, FP_dom
    SET A, [FP0]
    SXB A
    SUB A, 0x80
    AND A, 0xFF
    IFB A, 1
        ADD [FP0_sqrt_odd], 1
    ASR A, 1
    ADD A, 0x80
    IFE A, 0
        IFE [FP0_sqrt_odd], 0
            SET PC, FP0_LD0
    SET [FP0_sqrt_exp], A
    SET [FP0_sqrtR0+2], [FP0+2]
    SET [FP0_sqrtR0+3], [FP0+3]
    SET [FP0_sqrtR0+4], [FP0+4]
    SET [FP0], 0x0080
    SET [FP1], 0x81
    SET [FP1+1], 0
    SET [FP1+2], 0x8000
    SET [FP1+3], 0
    SET [FP1+4], 0
    JSR FP0_add
    JSR FP0_div2
    SET [FP1], 0x0080
    SET [FP1+1], 0
    SET [FP1+2], [FP0+2]
    SET [FP1+3], [FP0+3]
    SET [FP1+4], [FP0+4]
    SET [FP0_sqrt_cou], 5
:FP0_sqrt_loop
    SET [FP0], 0x0080
    SET [FP0+1], 0
    SET [FP0+2], [FP0_sqrtR0+2]
    SET [FP0+3], [FP0_sqrtR0+3]
    SET [FP0+4], [FP0_sqrtR0+4]
    JSR FP0_div
    JSR FP0_add
    JSR FP0_div2
    SET [FP1], [FP0]
    SET [FP1+1], [FP0+1]
    SET [FP1+2], [FP0+2]
    SET [FP1+3], [FP0+3]
    SET [FP1+4], [FP0+4]

    SUB [FP0_sqrt_cou], 1
    IFN [FP0_sqrt_cou], 0
        SET PC, FP0_sqrt_loop

    SET [FP0], [FP0_sqrt_exp]
    IFE [FP0_sqrt_odd], 0
        SET PC, FP0_nrm

    SET [FP1], [FP_c_sqrt2]
    SET [FP1+1], [FP_c_sqrt2+1]
    SET [FP1+2], [FP_c_sqrt2+2]
    SET [FP1+3], [FP_c_sqrt2+3]
    SET [FP1+4], [FP_c_sqrt2+4]
    SET PC, FP0_mul

; FP0 = 1.0
:FP0_LD1 
    SET [FP0], 0x0081
    SET [FP0+1], 0
    SET [FP0+2], 0x8000
    SET [FP0+3], 0
    SET [FP0+4], 0
    SET PC, POP

; FP0 = e^C (register C, considered signed)
:FP0_exp_n
    IFU C, 0
        SET PC, FP0_exp_mn
    ; FP0 = 1.0
    SET [FP0], 0x0081
    SET [FP0+1], 0
    SET [FP0+2], 0x8000
    SET [FP0+3], 0
    SET [FP0+4], 0
    SET [FP1], [FP_c_e]
    SET [FP1+1], [FP_c_e+1]
    SET [FP1+2], [FP_c_e+2]
    SET [FP1+3], [FP_c_e+3]
    SET [FP1+4], [FP_c_e+4]
:FP0_exp_n_loop
    IFE C, 0
        SET PC, POP
    JSR FP0_mul
    SUB C, 1
    SET PC, FP0_exp_n_loop
        
:FP0_exp_mn
    XOR C, 0xFFFF
    ADD C, 1
    JSR FP0_exp_n
    SET [FP1], [FP0]
    SET [FP1+1], [FP0+1]
    SET [FP1+2], [FP0+2]
    SET [FP1+3], [FP0+3]
    SET [FP1+4], [FP0+4]
    ; FP0 = 1.0
    SET [FP0], 0x0081
    SET [FP0+1], 0
    SET [FP0+2], 0x8000
    SET [FP0+3], 0
    SET [FP0+4], 0
    SET PC, FP0_div

; converts FP0 to unsigned 16-bit int -> A
; (FP0 sign is ignored)
; if too big to fit, return 0xFFFF
:FP0_int
    SET A, 0
    IFL [FP0], 0x81
        SET PC, POP
    IFG [FP0], 0xb0
        SET PC, POP
    SET [FTMP+8], 0
    SET [FTMP+9], 0
    SET [FTMP+10], 0
    SET [FTMP+11], [FP0+2]
    SET [FTMP+12], [FP0+3]
    SET [FTMP+13], [FP0+4]
    SET A, [FP0]
    SUB A, 0x80
    IFG A, 15
        SET PC, FP0_int_ovf     
    SHL [FTMP+13], A
    ROL [FTMP+12], A
    ROL [FTMP+11], A
    ROL [FTMP+10], A
    SET A, [FTMP+10]
    SET PC, POP
:FP0_int_ovf
    SET A, 0xFFFF
    SET PC, POP

; converts FP0 to unsigned 32-bit int -> A(lo),B(hi)
; (FP0 sign is ignored)
; if too big to fit, return 0xFFFF,0xFFFF
:FP0_int32
    SET A, 0
    SET B, 0
    IFL [FP0], 0x81
        SET PC, POP
    IFG [FP0], 0xe0
        SET PC, FP0_int32_ovf
    SET [FTMP+8], 0
    SET [FTMP+9], 0
    SET [FTMP+10], 0
    SET [FTMP+11], [FP0+2]
    SET [FTMP+12], [FP0+3]
    SET [FTMP+13], [FP0+4]
    SET A, [FP0]
    SUB A, 0x80
    IFG A, 31
        SET PC, FP0_int32_ovf 
    IFG A, 15
        SET PC, FP0_int32_ds    
    SHL [FTMP+13], A
    ROL [FTMP+12], A
    ROL [FTMP+11], A
    ROL [FTMP+10], A
    ROL [FTMP+9], A
    SET B, [FTMP+9]
    SET A, [FTMP+10]
    SET PC, POP
:FP0_int32_ds
    SUB A, 16
    SET [FTMP+8], [FTMP+9]
    SET [FTMP+9], [FTMP+10]
    SET [FTMP+10], [FTMP+11]
    SET [FTMP+11], [FTMP+12]
    SET [FTMP+12], [FTMP+13]
    SHL [FTMP+13], A
    ROL [FTMP+12], A
    ROL [FTMP+11], A
    ROL [FTMP+10], A
    ROL [FTMP+9], A
    SET B, [FTMP+9]
    SET A, [FTMP+10]
    SET PC, POP
:FP0_int32_ovf
    SET A, 0xFFFF
    SET B, 0xFFFF
    SET PC, POP

; attempt to convert FP0 to signed 32-bit int
; if unsuccessful, sets FPERROR to overflow
; if successful, stores low word to FTMP and high to FTMP+1
:FP0_int32_adv
    ; check if FP0=-2147483648.0
    IFE [FP0], 0x00a0
        IFE [FP0+1], 0xFFFF
            IFE [FP0+2], 0x8000
                SET PC, FP0_int32_adv_N231_c
    JSR FP0_int32
    IFG B, 0x8000
        SET PC, FP_ovf
    IFE B, 0x8000
        IFE A, 0x0000
            IFN [FP0+1], 0
                SET PC, FP0_int32_adv_N231
    IFE B, 0x8000
        SET PC, FP_ovf
:FP0_int32_adv_N231
    SET [FTMP], A
    SET [FTMP+1], B
    IFE [FP0+1], 0
        SET PC, POP
    XOR [FTMP], 0xFFFF
    XOR [FTMP+1], 0xFFFF
    ADD [FTMP], 1
    ADX [FTMP+1], 0
    SET PC, POP
:FP0_int32_adv_N231_c
    SET [FTMP], 0x0000
    SET [FTMP+1], 0x8000
    SET PC, POP

; remove integer portion from FP0
; (FP0 sign is ignored)
; Used registers: A
:FP0_frac
    IFL [FP0], 0x81
        SET PC, POP
    IFG [FP0], 0xb0
        SET PC, FP0_LD0
    SET A, [FP0]
    SUB A, 0x80
    IFG A, 15
        JSR FP0_frac_tr
    IFG A, 15
        JSR FP0_frac_tr
    SHL [FP0+4], A
    ROL [FP0+3], A
    ROL [FP0+2], A
    SUB [FP0], A
    IFU [FP0], 1
        SET PC, FP0_LD0
    SET PC, FP0_nrmz

:FP0_frac_tr
    SUB A, 16
    SET [FP0+2], [FP0+3]
    SET [FP0+3], [FP0+4]
    SET [FP0+4], 0
    SET PC, POP

; remove fractional portion from FP0
; (FP0 sign is ignored)
; Used registers: A
:FP0_nofrac
    IFL [FP0], 0x81
        SET PC, FP0_LD0
    IFG [FP0], 0xb0
        SET PC, POP
    SET A, [FP0]
    SUB A, 0x80
    IFG A, 15
        JSR FP0_nofrac_tr
    IFG A, 15
        JSR FP0_nofrac_tr
    SHR [FP0+2], A
    ROR [FP0+3], A
    ROR [FP0+4], A
    ADD [FP0], A
    SET PC, FP0_nrmz

:FP0_nofrac_tr
    SUB A, 16
    SET [FP0+4], [FP0+3]
    SET [FP0+3], [FP0+2]
    SET [FP0+2], 0
    SET PC, POP

:FP0_exp_R0
    DAT 0, 0, 0, 0, 0
:FP0_exp_R1
    DAT 0, 0, 0, 0, 0
:FP0_exp_R2
    DAT 0, 0, 0, 0, 0
:FP0_exp_R3
    DAT 0, 0, 0, 0, 0
:FP0_exp_cou
    DAT 0
; FP0 = exp(FP0)
; FP1 is destroyed!
:FP0_exp
    IFN [FP0+1], 0
        SET PC, FP0_exp_m
    SET [FP0_exp_cou], 0
    ; FP0_exp_R0 = 1.0
    SET [FP0_exp_R0], 0x0081
    SET [FP0_exp_R0+1], 0
    SET [FP0_exp_R0+2], 0x8000
    SET [FP0_exp_R0+3], 0
    SET [FP0_exp_R0+4], 0
    SET [FP0_exp_R1], [FP0]
    SET [FP0_exp_R1+1], [FP0+1]
    SET [FP0_exp_R1+2], [FP0+2]
    SET [FP0_exp_R1+3], [FP0+3]
    SET [FP0_exp_R1+4], [FP0+4]
    SET [FP0_exp_R2], 0x0081
    SET [FP0_exp_R2+1], 0
    SET [FP0_exp_R2+2], 0x8000
    SET [FP0_exp_R2+3], 0
    SET [FP0_exp_R2+4], 0
    JSR FP0_int
    SET C, A
    IFG C, 89
        SET PC, FP_ovf
    JSR FP0_exp_n
    SET [FP0_exp_R3], [FP0]
    SET [FP0_exp_R3+1], [FP0+1]
    SET [FP0_exp_R3+2], [FP0+2]
    SET [FP0_exp_R3+3], [FP0+3]
    SET [FP0_exp_R3+4], [FP0+4]
    SET [FP0], [FP0_exp_R1]
    SET [FP0+1], [FP0_exp_R1+1]
    SET [FP0+2], [FP0_exp_R1+2]
    SET [FP0+3], [FP0_exp_R1+3]
    SET [FP0+4], [FP0_exp_R1+4]
    JSR FP0_frac
    SET [FP0_exp_R1], [FP0]
    SET [FP0_exp_R1+1], [FP0+1]
    SET [FP0_exp_R1+2], [FP0+2]
    SET [FP0_exp_R1+3], [FP0+3]
    SET [FP0_exp_R1+4], [FP0+4]
:FP0_exp_loop
    SET [FP0], [FP0_exp_R1]
    SET [FP0+1], [FP0_exp_R1+1]
    SET [FP0+2], [FP0_exp_R1+2]
    SET [FP0+3], [FP0_exp_R1+3]
    SET [FP0+4], [FP0_exp_R1+4]
    SET [FP1], [FP0_exp_R0]
    SET [FP1+1], [FP0_exp_R0+1]
    SET [FP1+2], [FP0_exp_R0+2]
    SET [FP1+3], [FP0_exp_R0+3]
    SET [FP1+4], [FP0_exp_R0+4]
    JSR FP0_mul
    SET [FP0_exp_R0], [FP0]
    SET [FP0_exp_R0+1], [FP0+1]
    SET [FP0_exp_R0+2], [FP0+2]
    SET [FP0_exp_R0+3], [FP0+3]
    SET [FP0_exp_R0+4], [FP0+4]
    SET I, [FP0_exp_cou]
    STI [FP1], [FP_c_expterms+I]
    STI [FP1+1], [FP_c_expterms+I]
    STI [FP1+2], [FP_c_expterms+I]
    STI [FP1+3], [FP_c_expterms+I]
    STI [FP1+4], [FP_c_expterms+I]
    JSR FP0_mul
    SET [FP1], [FP0]
    SET [FP1+1], [FP0+1]
    SET [FP1+2], [FP0+2]
    SET [FP1+3], [FP0+3]
    SET [FP1+4], [FP0+4]
    SET [FP0], [FP0_exp_R2]
    SET [FP0+1], [FP0_exp_R2+1]
    SET [FP0+2], [FP0_exp_R2+2]
    SET [FP0+3], [FP0_exp_R2+3]
    SET [FP0+4], [FP0_exp_R2+4]
    JSR FP0_add
    SET [FP0_exp_R2], [FP0]
    SET [FP0_exp_R2+1], [FP0+1]
    SET [FP0_exp_R2+2], [FP0+2]
    SET [FP0_exp_R2+3], [FP0+3]
    SET [FP0_exp_R2+4], [FP0+4]
    ADD [FP0_exp_cou], 5
    IFL [FP0_exp_cou], 95
        SET PC, FP0_exp_loop
    SET [FP1], [FP0_exp_R3]
    SET [FP1+1], [FP0_exp_R3+1]
    SET [FP1+2], [FP0_exp_R3+2]
    SET [FP1+3], [FP0_exp_R3+3]
    SET [FP1+4], [FP0_exp_R3+4]
    SET PC, FP0_mul
    
:FP0_exp_m
    JSR FP0_neg
    JSR FP0_exp
    SET [FP1], [FP0]
    SET [FP1+1], [FP0+1]
    SET [FP1+2], [FP0+2]
    SET [FP1+3], [FP0+3]
    SET [FP1+4], [FP0+4]
    ; FP0 = 1.0
    SET [FP0], 0x0081
    SET [FP0+1], 0
    SET [FP0+2], 0x8000
    SET [FP0+3], 0
    SET [FP0+4], 0
    SET PC, FP0_div

:FP0_ln_R0
    DAT 0, 0, 0, 0, 0
:FP0_ln_R1
    DAT 0, 0, 0, 0, 0
:FP0_ln_R2
    DAT 0, 0, 0, 0, 0
:FP0_ln_exp
    DAT 0
:FP0_ln_cou
    DAT 0
; FP0 = ln(FP0) (log base e)
; FP1 is destroyed!
:FP0_ln
    IFN [FP0+1], 0
        SET PC, FP_dom
    IFE [FP0], 0
        SET PC, FP_dom
    ; FP0 = 1.0?
    IFE [FP0], 0x81
        IFE [FP0+2], 0x8000
            IFE [FP0+3], 0
                IFE [FP0+4], 0
                    SET PC, FP0_LD0
    SET [FP0_ln_exp], [FP0]
    SET [FP0_ln_cou], 0
    ; FP1 = 1.0
    SET [FP0], 0x0080
    SET [FP0+1], 0x0000
    SET [FP1], 0x0081
    SET [FP1+1], 0x0000
    SET [FP1+2], 0x8000
    SET [FP1+3], 0x0000
    SET [FP1+4], 0x0000
    JSR FP0_sub 
    SET [FP0_ln_R2], 0
    SET [FP0_ln_R2+1], 0
    SET [FP0_ln_R2+2], 0
    SET [FP0_ln_R2+3], 0
    SET [FP0_ln_R2+4], 0
    SET [FP0_ln_R0], [FP0]
    SET [FP0_ln_R0+1], [FP0+1]
    SET [FP0_ln_R0+2], [FP0+2]
    SET [FP0_ln_R0+3], [FP0+3]
    SET [FP0_ln_R0+4], [FP0+4]
    SET [FP0_ln_R1], [FP0]
    SET [FP0_ln_R1+1], [FP0+1]
    SET [FP0_ln_R1+2], [FP0+2]
    SET [FP0_ln_R1+3], [FP0+3]
    SET [FP0_ln_R1+4], [FP0+4]
:FP0_ln_loop
    SET [FP0], [FP0_ln_R0]
    SET [FP0+1], [FP0_ln_R0+1]
    SET [FP0+2], [FP0_ln_R0+2]
    SET [FP0+3], [FP0_ln_R0+3]
    SET [FP0+4], [FP0_ln_R0+4]
    SET I, [FP0_ln_cou]
    STI [FP1], [FP_c_lnterms+I]
    STI [FP1+1], [FP_c_lnterms+I]
    STI [FP1+2], [FP_c_lnterms+I]
    STI [FP1+3], [FP_c_lnterms+I]
    STI [FP1+4], [FP_c_lnterms+I]
    JSR FP0_mul
    IFB [FP0_ln_cou], 1            ; counter odd (0, 5, 10)...
        JSR FP0_neg
    SET [FP1], [FP0_ln_R2]
    SET [FP1+1], [FP0_ln_R2+1]
    SET [FP1+2], [FP0_ln_R2+2]
    SET [FP1+3], [FP0_ln_R2+3]
    SET [FP1+4], [FP0_ln_R2+4]
    JSR FP0_add
    SET [FP0_ln_R2], [FP0]
    SET [FP0_ln_R2+1], [FP0+1]
    SET [FP0_ln_R2+2], [FP0+2]
    SET [FP0_ln_R2+3], [FP0+3]
    SET [FP0_ln_R2+4], [FP0+4]
    SET [FP0], [FP0_ln_R0]
    SET [FP0+1], [FP0_ln_R0+1]
    SET [FP0+2], [FP0_ln_R0+2]
    SET [FP0+3], [FP0_ln_R0+3]
    SET [FP0+4], [FP0_ln_R0+4]
    SET [FP1], [FP0_ln_R1]
    SET [FP1+1], [FP0_ln_R1+1]
    SET [FP1+2], [FP0_ln_R1+2]
    SET [FP1+3], [FP0_ln_R1+3]
    SET [FP1+4], [FP0_ln_R1+4]
    JSR FP0_mul
    SET [FP0_ln_R0], [FP0]
    SET [FP0_ln_R0+1], [FP0+1]
    SET [FP0_ln_R0+2], [FP0+2]
    SET [FP0_ln_R0+3], [FP0+3]
    SET [FP0_ln_R0+4], [FP0+4]
    ADD [FP0_ln_cou], 5
    IFL [FP0_ln_cou], 200
        SET PC, FP0_ln_loop
    SET [FP0], 0x87
    SET [FP0+1], 0
    SET A, [FP0_ln_exp]
    SUB A, 0x80
    IFA A, 0xFFFF
        SET PC, FP0_lnnoneg
    XOR [FP0+1], 0xFFFF
    XOR A, 0xFFFF
    ADD A, 1
:FP0_lnnoneg
    SHL A, 9
    SET [FP0+2], A
    SET [FP0+3], 0
    SET [FP0+4], 0
    JSR FP0_nrm
    SET [FP1], [FP_c_ln2]
    SET [FP1+1], [FP_c_ln2+1]
    SET [FP1+2], [FP_c_ln2+2]
    SET [FP1+3], [FP_c_ln2+3]
    SET [FP1+4], [FP_c_ln2+4]
    JSR FP0_mul
    IFN [FPERROR], 0
        SET PC, POP
    SET [FP1], [FP0_ln_R2]
    SET [FP1+1], [FP0_ln_R2+1]
    SET [FP1+2], [FP0_ln_R2+2]
    SET [FP1+3], [FP0_ln_R2+3]
    SET [FP1+4], [FP0_ln_R2+4]
    SET PC, FP0_add

; FP0 = FP0 ^ FP1
; FP1 is destroyed!
:FP0_pow_tmp
    DAT 0, 0, 0, 0, 0
:FP0_pow
    IFE [FP1], 0                ; FP1 == 0.0?
        SET PC, FP0_LD1
    IFE [FP0], 0                ; FP0 == 0.0?
        IFE [FP1+1], 0          ; FP1 > 0.0?
            SET PC, FP0_LD0 
    IFE [FP0], 0                ; FP0 == 0.0?
        IFN [FP1+1], 0          ; FP1 < 0.0?
            SET PC, FP_d0
    IFN [FP0+1], 0              ; FP0 < 0.0?
        SET PC, FP0_pow_neg
    SET [FP0_pow_tmp], [FP1]
    SET [FP0_pow_tmp+1], [FP1+1]
    SET [FP0_pow_tmp+2], [FP1+2]
    SET [FP0_pow_tmp+3], [FP1+3]
    SET [FP0_pow_tmp+4], [FP1+4]
    JSR FP0_ln
    SET [FP1], [FP0_pow_tmp]
    SET [FP1+1], [FP0_pow_tmp+1]
    SET [FP1+2], [FP0_pow_tmp+2]
    SET [FP1+3], [FP0_pow_tmp+3]
    SET [FP1+4], [FP0_pow_tmp+4]
    JSR FP0_mul
    SET PC, FP0_exp

:FP0_pow_neg
    SET [FP0_pow_tmp], [FP0]
    SET [FP0_pow_tmp+1], [FP0+1]
    SET [FP0_pow_tmp+2], [FP0+2]
    SET [FP0_pow_tmp+3], [FP0+3]
    SET [FP0_pow_tmp+4], [FP0+4]
    SET [FP0], [FP1]
    SET [FP0+1], [FP1+1]
    SET [FP0+2], [FP1+2]
    SET [FP0+3], [FP1+3]
    SET [FP0+4], [FP1+4]
    JSR FP0_int32
    SET PUSH, A
    SET PUSH, B
    JSR FP0_frac
    SET B, POP
    SET A, POP
    IFN [FP0], 0
        SET PC, FP_dom          ; FP1 cannot be fractional
    IFU B, 0
        SET PC, FP0_pow_neg_1N
    IFN B, 0
        SET PC, FP_ovf
    IFG A, 0x7FFF
        SET PC, FP_ovf
    SET C, A
    SET [FP0], [FP0_pow_tmp]
    SET [FP0+1], [FP0_pow_tmp+1]
    SET [FP0+2], [FP0_pow_tmp+2]
    SET [FP0+3], [FP0_pow_tmp+3]
    SET [FP0+4], [FP0_pow_tmp+4]
    SET PC, FP0_pow_n
:FP0_pow_neg_1N
    IFN B, 0xFFFF
        SET PC, FP0_LD0
    IFU A, 0
        SET PC, FP0_pow_neg_1N_OK
    SET PC, FP0_LD0
:FP0_pow_neg_1N_OK
    SET C, A
    SET [FP0], [FP0_pow_tmp]
    SET [FP0+1], [FP0_pow_tmp+1]
    SET [FP0+2], [FP0_pow_tmp+2]
    SET [FP0+3], [FP0_pow_tmp+3]
    SET [FP0+4], [FP0_pow_tmp+4]
    SET PC, FP0_pow_n

; FP0 = FP0^C (register C, considered signed)
:FP0_pow_n
    IFU C, 0
        SET PC, FP0_pow_mn
    ; FP0 = 1.0
    SET [FP1], [FP0]
    SET [FP1+1], [FP0+1]
    SET [FP1+2], [FP0+2]
    SET [FP1+3], [FP0+3]
    SET [FP1+4], [FP0+4]
    JSR FP0_LD1
:FP0_pow_n_loop
    IFE C, 0
        SET PC, POP
    JSR FP0_mul
    SUB C, 1
    SET PC, FP0_pow_n_loop
        
:FP0_pow_mn
    XOR C, 0xFFFF
    ADD C, 1
    SET [FP1], [FP0]
    SET [FP1+1], [FP0+1]
    SET [FP1+2], [FP0+2]
    SET [FP1+3], [FP0+3]
    SET [FP1+4], [FP0+4]
    ; FP0 = 1.0
    SET [FP0], 0x0081
    SET [FP0+1], 0
    SET [FP0+2], 0x8000
    SET [FP0+3], 0
    SET [FP0+4], 0
    JSR FP0_div
    SET PC, FP0_pow_n

:FP0_atan_R0
    DAT 0, 0, 0, 0, 0
:FP0_atan_R1
    DAT 0, 0, 0, 0, 0
:FP0_atan_R2
    DAT 0, 0, 0, 0, 0
:FP0_atan_cou
    DAT 0
; FP0 = atan(FP0), radians
; FP1 is destroyed!
:FP0_atan
    IFE [FP0], 0
        SET PC, FP0_LD0
    IFN [FP0+1], 0
        SET PC, FP0_atan_m
    IFG [FP0], 0x80    
        SET PC, FP0_atan_inv
    IFE [FP0], 0x80    
        SET PC, FP0_atan_shift
    SET [FP0_atan_R2], 0
    SET [FP0_atan_R2+1], 0
    SET [FP0_atan_R2+2], 0
    SET [FP0_atan_R2+3], 0
    SET [FP0_atan_R2+4], 0
    SET [FP0_atan_cou], 0
    SET [FP0_atan_R0], [FP0]
    SET [FP0_atan_R0+1], [FP0+1]
    SET [FP0_atan_R0+2], [FP0+2]
    SET [FP0_atan_R0+3], [FP0+3]
    SET [FP0_atan_R0+4], [FP0+4]
    SET [FP1], [FP0]
    SET [FP1+1], [FP0+1]
    SET [FP1+2], [FP0+2]
    SET [FP1+3], [FP0+3]
    SET [FP1+4], [FP0+4]
    JSR FP0_mul
    SET [FP0_atan_R1], [FP0]
    SET [FP0_atan_R1+1], [FP0+1]
    SET [FP0_atan_R1+2], [FP0+2]
    SET [FP0_atan_R1+3], [FP0+3]
    SET [FP0_atan_R1+4], [FP0+4]
:FP0_atan_loop
    SET [FP0], [FP0_atan_R0]
    SET [FP0+1], [FP0_atan_R0+1]
    SET [FP0+2], [FP0_atan_R0+2]
    SET [FP0+3], [FP0_atan_R0+3]
    SET [FP0+4], [FP0_atan_R0+4]
    SET I, [FP0_atan_cou]
    STI [FP1], [I+FP_c_atanterms]
    STI [FP1+1], [I+FP_c_atanterms]
    STI [FP1+2], [I+FP_c_atanterms]
    STI [FP1+3], [I+FP_c_atanterms]
    STI [FP1+4], [I+FP_c_atanterms]
    JSR FP0_mul
    IFN [FPERROR], 0
        SET PC, POP
    SET [FP1], [FP0_atan_R2]
    SET [FP1+1], [FP0_atan_R2+1]
    SET [FP1+2], [FP0_atan_R2+2]
    SET [FP1+3], [FP0_atan_R2+3]
    SET [FP1+4], [FP0_atan_R2+4]
    JSR FP0_add
    IFN [FPERROR], 0
        SET PC, POP
    SET [FP0_atan_R2], [FP0]
    SET [FP0_atan_R2+1], [FP0+1]
    SET [FP0_atan_R2+2], [FP0+2]
    SET [FP0_atan_R2+3], [FP0+3]
    SET [FP0_atan_R2+4], [FP0+4]
    SET [FP0], [FP0_atan_R0]
    SET [FP0+1], [FP0_atan_R0+1]
    SET [FP0+2], [FP0_atan_R0+2]
    SET [FP0+3], [FP0_atan_R0+3]
    SET [FP0+4], [FP0_atan_R0+4]
    SET [FP1], [FP0_atan_R1]
    SET [FP1+1], [FP0_atan_R1+1]
    SET [FP1+2], [FP0_atan_R1+2]
    SET [FP1+3], [FP0_atan_R1+3]
    SET [FP1+4], [FP0_atan_R1+4]
    JSR FP0_mul
    IFN [FPERROR], 0
        SET PC, POP
    SET [FP0_atan_R0], [FP0]
    SET [FP0_atan_R0+1], [FP0+1]
    SET [FP0_atan_R0+2], [FP0+2]
    SET [FP0_atan_R0+3], [FP0+3]
    SET [FP0_atan_R0+4], [FP0+4]

    ADD [FP0_atan_cou], 5
    IFL [FP0_atan_cou], 95
        SET PC, FP0_atan_loop
    
    SET [FP0], [FP0_atan_R2]
    SET [FP0+1], [FP0_atan_R2+1]
    SET [FP0+2], [FP0_atan_R2+2]
    SET [FP0+3], [FP0_atan_R2+3]
    SET [FP0+4], [FP0_atan_R2+4]
    SET PC, POP

:FP0_atan_m
    JSR FP0_neg
    JSR FP0_atan    
    SET PC, FP0_neg

:FP0_atan_inv
    IFN [FP0], 0x81
        SET PC, FP0_atan_invR
    IFN [FP0+2], 0x8000
        SET PC, FP0_atan_invR
    IFN [FP0+3], 0
        SET PC, FP0_atan_invR
    IFN [FP0+3], 0
        SET PC, FP0_atan_invR
    SET [FP0], [FP_c_atan1]
    SET [FP0+1], [FP_c_atan1+1]
    SET [FP0+2], [FP_c_atan1+2]
    SET [FP0+3], [FP_c_atan1+3]
    SET [FP0+4], [FP_c_atan1+4]
    SET PC, POP
; 1 < x
; atan(x) = pi/2 - atan(1/x)
:FP0_atan_invR
    SET [FP1], [FP0]
    SET [FP1+1], [FP0+1]
    SET [FP1+2], [FP0+2]
    SET [FP1+3], [FP0+3]
    SET [FP1+4], [FP0+4]
    ; FP0 = 1.0
    SET [FP0], 0x81
    SET [FP0+1], 0
    SET [FP0+2], 0x8000
    SET [FP0+3], 0
    SET [FP0+4], 0
    JSR FP0_div
    JSR FP0_atan
    JSR FP0_neg
    SET [FP1], [FP_c_halfpi]
    SET [FP1+1], [FP_c_halfpi+1]
    SET [FP1+2], [FP_c_halfpi+2]
    SET [FP1+3], [FP_c_halfpi+3]
    SET [FP1+4], [FP_c_halfpi+4]
    SET PC, FP0_add

:FP0_atan_shift_tmp
    DAT 0, 0, 0, 0, 0
:FP0_atan_shift_tmp2
    DAT 0, 0, 0, 0, 0
; 0.5 < x < 1
; atan(x) = atan(1/2) + atan((2x-1)/(x+2))
:FP0_atan_shift 
    SET [FP0_atan_shift_tmp], [FP0]
    SET [FP0_atan_shift_tmp+1], [FP0+1]
    SET [FP0_atan_shift_tmp+2], [FP0+2]
    SET [FP0_atan_shift_tmp+3], [FP0+3]
    SET [FP0_atan_shift_tmp+4], [FP0+4]
    ; FP1 = 2.0
    SET [FP1], 0x82
    SET [FP1+1], 0
    SET [FP1+2], 0x8000
    SET [FP1+3], 0
    SET [FP1+4], 0
    JSR FP0_add
    SET [FP0_atan_shift_tmp2], [FP0]
    SET [FP0_atan_shift_tmp2+1], [FP0+1]
    SET [FP0_atan_shift_tmp2+2], [FP0+2]
    SET [FP0_atan_shift_tmp2+3], [FP0+3]
    SET [FP0_atan_shift_tmp2+4], [FP0+4]
    SET [FP0], [FP0_atan_shift_tmp]
    SET [FP0+1], [FP0_atan_shift_tmp+1]
    SET [FP0+2], [FP0_atan_shift_tmp+2]
    SET [FP0+3], [FP0_atan_shift_tmp+3]
    SET [FP0+4], [FP0_atan_shift_tmp+4]
    JSR FP0_mul2 ; FP0 [0.5, 1[, no overflow
    ; FP1 = 1.0
    SET [FP1], 0x81
    SET [FP1+1], 0
    SET [FP1+2], 0x8000
    SET [FP1+3], 0
    SET [FP1+4], 0
    JSR FP0_sub
    SET [FP1], [FP0_atan_shift_tmp2]
    SET [FP1+1], [FP0_atan_shift_tmp2+1]
    SET [FP1+2], [FP0_atan_shift_tmp2+2]
    SET [FP1+3], [FP0_atan_shift_tmp2+3]
    SET [FP1+4], [FP0_atan_shift_tmp2+4]
    JSR FP0_div
    JSR FP0_atan
    SET [FP1], [FP_c_atanH]
    SET [FP1+1], [FP_c_atanH+1]
    SET [FP1+2], [FP_c_atanH+2]
    SET [FP1+3], [FP_c_atanH+3]
    SET [FP1+4], [FP_c_atanH+4]
    SET PC, FP0_add

:FP0_sin_R0
    DAT 0, 0, 0, 0, 0
:FP0_sin_R1
    DAT 0, 0, 0, 0, 0
:FP0_sin_R2
    DAT 0, 0, 0, 0, 0
:FP0_sin_cou
    DAT 0
; FP0 = cos(FP0), radians
; FP1 is destroyed!
:FP0_cos
    SET [FP1], [FP_c_halfpi]
    SET [FP1+1], [FP_c_halfpi+1]
    SET [FP1+2], [FP_c_halfpi+2]
    SET [FP1+3], [FP_c_halfpi+3]
    SET [FP1+4], [FP_c_halfpi+4]
    JSR FP0_add
; FP0 = sin(FP0), radians
; FP1 is destroyed!
:FP0_sin
    IFE [FP0], 0
        SET PC, FP0_LD0
    SET [FP1], [FP_c_tau]
    SET [FP1+1], [FP_c_tau+1]
    SET [FP1+2], [FP_c_tau+2]
    SET [FP1+3], [FP_c_tau+3]
    SET [FP1+4], [FP_c_tau+4]
    JSR FP0_div
    JSR FP0_frac
    JSR FP0_mul
    SET [FP0_sin_R2], 0
    SET [FP0_sin_R2+1], 0
    SET [FP0_sin_R2+2], 0
    SET [FP0_sin_R2+3], 0
    SET [FP0_sin_R2+4], 0
    SET [FP0_sin_cou], 0
    SET [FP0_sin_R0], [FP0]
    SET [FP0_sin_R0+1], [FP0+1]
    SET [FP0_sin_R0+2], [FP0+2]
    SET [FP0_sin_R0+3], [FP0+3]
    SET [FP0_sin_R0+4], [FP0+4]
    SET [FP1], [FP0]
    SET [FP1+1], [FP0+1]
    SET [FP1+2], [FP0+2]
    SET [FP1+3], [FP0+3]
    SET [FP1+4], [FP0+4]
    JSR FP0_mul
    SET [FP0_sin_R1], [FP0]
    SET [FP0_sin_R1+1], [FP0+1]
    SET [FP0_sin_R1+2], [FP0+2]
    SET [FP0_sin_R1+3], [FP0+3]
    SET [FP0_sin_R1+4], [FP0+4]
:FP0_sin_loop
    SET [FP0], [FP0_sin_R0]
    SET [FP0+1], [FP0_sin_R0+1]
    SET [FP0+2], [FP0_sin_R0+2]
    SET [FP0+3], [FP0_sin_R0+3]
    SET [FP0+4], [FP0_sin_R0+4]
    SET I, [FP0_sin_cou]
    STI [FP1], [I+FP_c_sinterms]
    STI [FP1+1], [I+FP_c_sinterms]
    STI [FP1+2], [I+FP_c_sinterms]
    STI [FP1+3], [I+FP_c_sinterms]
    STI [FP1+4], [I+FP_c_sinterms]
    JSR FP0_mul
    IFN [FPERROR], 0
        SET PC, POP
    SET [FP1], [FP0_sin_R2]
    SET [FP1+1], [FP0_sin_R2+1]
    SET [FP1+2], [FP0_sin_R2+2]
    SET [FP1+3], [FP0_sin_R2+3]
    SET [FP1+4], [FP0_sin_R2+4]
    JSR FP0_add
    IFN [FPERROR], 0
        SET PC, POP
    SET [FP0_sin_R2], [FP0]
    SET [FP0_sin_R2+1], [FP0+1]
    SET [FP0_sin_R2+2], [FP0+2]
    SET [FP0_sin_R2+3], [FP0+3]
    SET [FP0_sin_R2+4], [FP0+4]
    SET [FP0], [FP0_sin_R0]
    SET [FP0+1], [FP0_sin_R0+1]
    SET [FP0+2], [FP0_sin_R0+2]
    SET [FP0+3], [FP0_sin_R0+3]
    SET [FP0+4], [FP0_sin_R0+4]
    SET [FP1], [FP0_sin_R1]
    SET [FP1+1], [FP0_sin_R1+1]
    SET [FP1+2], [FP0_sin_R1+2]
    SET [FP1+3], [FP0_sin_R1+3]
    SET [FP1+4], [FP0_sin_R1+4]
    JSR FP0_mul
    IFN [FPERROR], 0
        SET PC, POP
    SET [FP0_sin_R0], [FP0]
    SET [FP0_sin_R0+1], [FP0+1]
    SET [FP0_sin_R0+2], [FP0+2]
    SET [FP0_sin_R0+3], [FP0+3]
    SET [FP0_sin_R0+4], [FP0+4]

    ADD [FP0_sin_cou], 5
    IFL [FP0_sin_cou], 85
        SET PC, FP0_sin_loop
    
    SET [FP0], [FP0_sin_R2]
    SET [FP0+1], [FP0_sin_R2+1]
    SET [FP0+2], [FP0_sin_R2+2]
    SET [FP0+3], [FP0_sin_R2+3]
    SET [FP0+4], [FP0_sin_R2+4]
    SET PC, POP

:FP0_tan_R0
    DAT 0, 0, 0, 0, 0
:FP0_tan_R1
    DAT 0, 0, 0, 0, 0
; FP0 = tan(FP0), radians
; FP1 is destroyed!
:FP0_tan
    SET [FP0_tan_R0], [FP0]
    SET [FP0_tan_R0+1], [FP0+1]
    SET [FP0_tan_R0+2], [FP0+2]
    SET [FP0_tan_R0+3], [FP0+3]
    SET [FP0_tan_R0+4], [FP0+4]
    JSR FP0_sin
    SET [FP0_tan_R1], [FP0]
    SET [FP0_tan_R1+1], [FP0+1]
    SET [FP0_tan_R1+2], [FP0+2]
    SET [FP0_tan_R1+3], [FP0+3]
    SET [FP0_tan_R1+4], [FP0+4]
    SET [FP0], [FP0_tan_R0]
    SET [FP0+1], [FP0_tan_R0+1]
    SET [FP0+2], [FP0_tan_R0+2]
    SET [FP0+3], [FP0_tan_R0+3]
    SET [FP0+4], [FP0_tan_R0+4]
    JSR FP0_cos
    SET [FP1], [FP0]
    SET [FP1+1], [FP0+1]
    SET [FP1+2], [FP0+2]
    SET [FP1+3], [FP0+3]
    SET [FP1+4], [FP0+4]
    SET [FP0], [FP0_tan_R1]
    SET [FP0+1], [FP0_tan_R1+1]
    SET [FP0+2], [FP0_tan_R1+2]
    SET [FP0+3], [FP0_tan_R1+3]
    SET [FP0+4], [FP0_tan_R1+4]
    SET PC, FP0_div

:str_num_ptr
    DAT 0
:str_num_sgn
    DAT 0
; String to number conversion
; Converts either to integer or floating point
; Takes:
;   A = pointer to string (ASCII)
; Returns:
;   A = 0x0001 if integer
;       0x0002 if floating point
;       0xFFFE if floating point error (overflow)
;       0xFFFF if invalid number
;       0x0000 if UB occurred, fear for your life
;   I = updated string pointer
;   FTMP+0 = lo word of integer if A = 1
;   FTMP+1 = hi word of integer if A = 1
;   FP0 = floating point value if A = 2
:str_num
    IFN [A], 0x0020 ; " "
        SET PC, str_num_sp
    ADD A, 1
    SET PC, str_num
:str_num_sp        
    SET [str_num_sgn], 0
    SET [str_num_ptr], A
    IFE [A], 0x002e ; "."
        SET PC, str_num_fp
    IFE [A], 0x002b ; "+"
        SET PC, str_num_pos
    IFG [A], 0x002F ; "0"-1
        IFL [A], 0x003A ; "9"+1
            SET PC, str_num_int
    IFE [A], 0x002d ; "-"
        SET PC, str_num_neg
    SET I, A
    SET A, 0xFFFF
    SET PC, POP
:str_num_neg
    SET [str_num_sgn], 0xFFFF
:str_num_pos
    ADD [str_num_ptr], 1
    ADD A, 1
:str_num_int
    IFE [A], 0x002e ; "."
        SET PC, str_num_fp
    SET [FTMP+0], 0
    SET [FTMP+1], 0
:str_num_int_loop
    IFE [A], 0x002e ; "."
        SET PC, str_num_fp
    IFE [A], 0x0065 ; "e"
        SET PC, str_num_fp
    IFE [A], 0x0045 ; "E"
        SET PC, str_num_fp
    IFL [A], 0x0030 ; "0"
        SET PC, str_num_int_end
    IFG [A], 0x0039 ; "9"
        SET PC, str_num_int_end
    MUL [FTMP+1], 10
    IFN EX, 0
        SET PC, str_num_fp
    IFB [FTMP+1], 0x8000
        SET PC, str_num_fp
    MUL [FTMP], 10
    ADX [FTMP+1], 0
    SET I, [A]
    SUB I, 0x0030 ; "0"
    ADD [FTMP], I
    ADX [FTMP+1], 0
    IFB [FTMP+1], 0x8000
        SET PC, str_num_fp
    ADD A, 1
    SET PC, str_num_int_loop
:str_num_int_end
    SET I, A
    SET A, 1
    IFE [str_num_sgn], 0
        SET PC, POP
    XOR [FTMP], 0xFFFF
    XOR [FTMP+1], 0xFFFF
    ADD [FTMP+1], 1
    ADX [FTMP], 0
    SET PC, POP

; convert integer str to 48-bit integer
; input: I
; output: J (hi word, med word, lo word)
:str_int48
    SET [J], 0
    SET [J+1], 0
    SET [J+2], 0
:str_int48_loop
    IFL [I], 0x0030 ; "0"
        SET PC, str_int48_end
    IFG [I], 0x0039 ; "0"
        SET PC, str_int48_end
    MUL [J], 10
    MUL [J+1], 10
    ADX [J], 0
    MUL [J+2], 10
    ADX [J+1], 0
    ADX [J], 0
    SET A, [I]
    SUB A, 0x0030     ; "0"
    ADD [J+2], A
    ADX [J+1], 0
    ADD I, 1
    SET PC, str_int48_loop
:str_int48_end
    SET PC, POP        

:str_num_fp
    SET A, [str_num_ptr]
    SET [STR3+249], 0 ; STR3+249: E+ exponent portion
    SET [STR3+250], 0 ; STR3+250: integer portion
    SET [STR3+251], 0
    SET [STR3+252], 0
    SET [FTMP], 0
    SET [FTMP+1], 0
    
    SET I, 0
:str_num_fp_copy0
    IFL [A], 0x0030 ; "0"
        SET PC, str_num_fp_done0
    IFG [A], 0x0039 ; "9"
        SET PC, str_num_fp_done0
    SET [I+STR3], [A]
    ADD A, 1
    ADD I, 1 
    IFL I, 14 ; 14 digits are enough
        SET PC, str_num_fp_copy0
:str_num_fp_done0
    JSR str_num_skipnum
    SET [str_num_ptr], A
    SET [I+STR3], 0
    SET I, STR3
    SET J, STR3+250
    JSR str_int48
    SET A, [str_num_ptr]
    JSR FP1_LD0
    IFE [A], 0x002e ; "."
        JSR str_num_fp_frac
    SET A, [str_num_ptr]
    IFE [A], 0x0065 ; "e"
        SET [A], 0x0045 ; "E"
    IFE [A], 0x0045 ; "E"
        JSR str_num_fp_exp
    IFN [FPERROR], 0
        SET PC, str_num_fperr
    SET [FP0], 0xb0 ; 2^48
    SET [FP0+1], [str_num_sgn]
    SET [FP0+2], [STR3+250]
    SET [FP0+3], [STR3+251]
    SET [FP0+4], [STR3+252]
    JSR FP0_nrmz
    JSR FP0_add
    JSR FP0_store
    ; FP0 = 1.0
    SET [FP0], 0x81
    SET [FP0+1], 0x0000
    SET [FP0+2], 0x8000
    SET [FP0+3], 0x0000
    SET [FP0+4], 0x0000
    ; now to parse the exponent at STR3+24
    IFE [str_num_fp_exp_sgn], 0
        SET PC, str_num_fp_exp_mul
    XOR [STR3+249], 0xFFFF
    ADD [STR3+249], 1
:str_num_fp_exp_mul
    IFN [FPERROR], 0
        SET PC, str_num_fperr
    IFA [STR3+249], 15
        SET PC, str_num_expp4
    IFU [STR3+249], 0xfff0 ; -15
        SET PC, str_num_expm4
    IFA [STR3+249], 3
        SET PC, str_num_expp2
    IFU [STR3+249], 0xfffc ; -3
        SET PC, str_num_expm2
    IFA [STR3+249], 0
        SET PC, str_num_expp0
    IFU [STR3+249], 0
        SET PC, str_num_expm0
    JSR FP1_load
    JSR FP0_mul
    SET A, 2
    SET I, [str_num_ptr]
    SET PC, POP

:str_num_expm0
    ADD [STR3+249], 1
    SET A, FP_c_10expm0
    JSR FP1_lc
    JSR FP0_mul
    SET PC, str_num_fp_exp_mul
:str_num_expp0
    SUB [STR3+249], 1
    SET A, FP_c_10expp0
    JSR FP1_lc
    JSR FP0_mul
    SET PC, str_num_fp_exp_mul
:str_num_expm2
    ADD [STR3+249], 4
    SET A, FP_c_10expm2
    JSR FP1_lc
    JSR FP0_mul
    SET PC, str_num_fp_exp_mul
:str_num_expp2
    SUB [STR3+249], 4
    SET A, FP_c_10expp2
    JSR FP1_lc
    JSR FP0_mul
    SET PC, str_num_fp_exp_mul
:str_num_expm4
    ADD [STR3+249], 16
    SET A, FP_c_10expm4
    JSR FP1_lc
    JSR FP0_mul
    SET PC, str_num_fp_exp_mul
:str_num_expp4
    SUB [STR3+249], 16
    SET A, FP_c_10expp4
    JSR FP1_lc
    JSR FP0_mul
    SET PC, str_num_fp_exp_mul

:str_num_fperr
    SET A, 0xFFFE
    SET PC, POP

:str_num_skipnum
    IFL [A], 0x0030 ; "0"
        SET PC, POP
    IFG [A], 0x0039 ; "9"
        SET PC, POP
    ADD A, 1
    SET PC, str_num_skipnum

:str_num_fp_frac
    JSR FP0_LD0
    SET I, 0
    SET A, [str_num_ptr]
:str_num_fp_copy1
    ADD A, 1
    IFL [A], 0x0030 ; "0"
        SET PC, str_num_fp_parse
    IFG [A], 0x0039 ; "9"
        SET PC, str_num_fp_parse
    SET [I+STR3], [A]
    ADD I, 1 
    IFL I, 14 ; 14 digits are enough
        SET PC, str_num_fp_copy1
:str_num_fp_parse
    JSR str_num_skipnum
    SET [str_num_ptr], A
    IFE I, 0
        SET PC, FP0_store
:str_num_fp_parse_loop
    SUB I, 1
    SET [FP1], 0x0090
    SET [FP1+1], 0
    SET [FP1+2], [I+STR3]
    SUB [FP1+2], 0x0030
    SET [FP1+3], 0
    SET [FP1+4], 0
    JSR FP1_nrmz
    JSR FP0_add
    SET A, FP_c_1em1
    JSR FP1_lc
    JSR FP0_mul
    IFG I, 0
        SET PC, str_num_fp_parse_loop
    JSR FP0_T1
    SET PC, POP

:str_num_fp_exp_sgn
    DAT 0
:str_num_fp_exp
    SET [str_num_fp_exp_sgn], 0
    SET I, 0
    SET A, [str_num_ptr]
    IFE [1+A], 0x002b ; "+"
        SET PC, str_num_fp_exp_p
    IFE [1+A], 0x002d ; "-"
        SET PC, str_num_fp_exp_n
    IFE [1+A], 0x4000 ; "+"
        SET PC, str_num_fp_exp_p
    IFE [1+A], 0x4001 ; "-"
        SET PC, str_num_fp_exp_n
:str_num_fp_copy2
    ADD A, 1
    IFL [A], 0x0030 ; "0"
        SET PC, str_num_fp_done2
    IFG [A], 0x0039 ; "9"
        SET PC, str_num_fp_done2
    SET [I+STR3], [A]
    ADD I, 1 
    IFL I, 5 ; 5 digits are enough
        SET PC, str_num_fp_copy2
:str_num_fp_done2   
    IFE I, 0
        SET PC, str_num_fp_exp0
    IFG I, 3
        SET PC, FP_ovf
    JSR str_num_skipnum
    SET [str_num_ptr], A
    SET [I+STR3], 0
    SET I, STR3
    SET J, STR3+247
    SET PC, str_int48    
:str_num_fp_exp0
    SET [STR3+247], 0
    SET [STR3+248], 0
    SET [STR3+249], 0
    SET PC, POP

:str_num_fp_exp_n
    SET [str_num_fp_exp_sgn], 0xffff
:str_num_fp_exp_p
    ADD A, 1
    SET PC, str_num_fp_copy2    

; Convert 32-bit integer to string
; Takes:
;   A = integer low byte
;   B = integer high byte
; Returns:
;   STR3+0 = string, null terminated
;           ("-2147483648" ... "0" ... "2147483647")
; Used registers:
;   A, B, I
:int_str 
    IFE A, 0
        IFE B, 0
            SET PC, int_str_zero
    SET [FTMP+14], B
    SET [FTMP+15], A
    SET B, 0
    SET I, 0
    SET [STR3], 0x0000     
    IFC [FTMP+14], 0x8000
        SET PC, int_str_noneg
    SET [STR3], 0x002d      ; "-"
    XOR [FTMP+15], 0xFFFF
    XOR [FTMP+14], 0xFFFF
    ADD [FTMP+15], 1
    ADX [FTMP+14], 0
    ADD I, 1
:int_str_noneg
    SET PUSH, I
    JSR int_str_bcd
    SET I, POP
:int_str_bcd_copy_loop
    SHL [FTMP+15], 4
    ROL [FTMP+14], 4
    ROL [FTMP+13], 4
    ROL [FTMP+12], 4
    ROL [FTMP+11], 4
    ROL [FTMP+10], 4
    SET A, EX
    IFE A, 15               ; 0xF end marker
        SET PC, int_str_bcd_copy_end
    BOR A, 0x0030
    SET [STR3+I], A
    ADD I, 1
    SET PC, int_str_bcd_copy_loop
:int_str_zero
    SET [STR3], 0x0030      ; "0"
    SET I, 1
:int_str_bcd_copy_end
    SET [STR3+I], 0         ; <NUL>
    SET PC, POP

; BCD conversion: [FTMP+14], [FTMP+15] -> BCD at FTMP+11
; with C digits in total
:int_str_bcd
    SET PUSH, C
    SET A, 0
    SET C, 14
    SET I, FTMP
    JSR mem_fill
    SET C, 32
:int_str_bcd_loop
    ; check every column
    SET A, [FTMP+11]
    AND A, 0xF000
    IFG A, 0x4000           ; >= 0x5000
        ADD [FTMP+11], 0x3000
    SET A, [FTMP+11]
    AND A, 0x0F00
    IFG A, 0x0400           ; >= 0x0500
        ADD [FTMP+11], 0x0300
    SET A, [FTMP+11]
    AND A, 0x00F0
    IFG A, 0x0040           ; >= 0x0050
        ADD [FTMP+11], 0x0030
    SET A, [FTMP+11]
    AND A, 0x000F
    IFG A, 0x0004           ; >= 0x0005
        ADD [FTMP+11], 0x0003

    SET A, [FTMP+12]
    AND A, 0xF000
    IFG A, 0x4000           ; >= 0x5000
        ADD [FTMP+12], 0x3000
    SET A, [FTMP+12]
    AND A, 0x0F00
    IFG A, 0x0400           ; >= 0x0500
        ADD [FTMP+12], 0x0300
    SET A, [FTMP+12]
    AND A, 0x00F0
    IFG A, 0x0040           ; >= 0x0050
        ADD [FTMP+12], 0x0030
    SET A, [FTMP+12]
    AND A, 0x000F
    IFG A, 0x0004           ; >= 0x0005
        ADD [FTMP+12], 0x0003

    SET A, [FTMP+13]
    AND A, 0xF000
    IFG A, 0x4000           ; >= 0x5000
        ADD [FTMP+13], 0x3000
    SET A, [FTMP+13]
    AND A, 0x0F00
    IFG A, 0x0400           ; >= 0x0500
        ADD [FTMP+13], 0x0300
    SET A, [FTMP+13]
    AND A, 0x00F0
    IFG A, 0x0040           ; >= 0x0050
        ADD [FTMP+13], 0x0030
    SET A, [FTMP+13]
    AND A, 0x000F
    IFG A, 0x0004           ; >= 0x0005
        ADD [FTMP+13], 0x0003

    SHL [FTMP+15], 1
    ROL [FTMP+14], 1
    ROL [FTMP+13], 1
    ROL [FTMP+12], 1
    ROL [FTMP+11], 1
    ROL [FTMP+10], 1

    SUB C, 1
    IFG C, 0
        SET PC, int_str_bcd_loop

    SET [FTMP+14], 0xF000   ; 0xF end marker
    ROL [FTMP+14], 4
    ROL [FTMP+13], 4
    ROL [FTMP+12], 4
    ROL [FTMP+11], 4
    ROL [FTMP+10], 4

:int_str_bcd_adj_loop
    IFB [FTMP+10], 0xF000   ; no initial digit?
        SET PC, int_str_bcd_adj_end
    SHL [FTMP+15], 4
    ROL [FTMP+14], 4
    ROL [FTMP+13], 4
    ROL [FTMP+12], 4
    ROL [FTMP+11], 4
    ROL [FTMP+10], 4
    SET PC, int_str_bcd_adj_loop
:int_str_bcd_adj_end
    SET C, POP
    SET PC, POP

:FP0_str_exp
    DAT 0
; Convert FP0 to string
; Returns:
;   STR3+0 = string, null terminated
;           ("-2147483648" ... "0" ... "2147483647")
:FP0_str              
    JSR FP1_store
    JSR FP0_store
    SET [FP0_str_exp], 0
    SET [STR3+256], 0x0020      ; " "
    IFN [FP0+1], 0
        SET [STR3+256], 0x002D  ; "-"
    SET [FP0+1], 0
    IFE [FP0], 0x00             ; zero
        SET PC, FP0_str_zero
    IFG [FP0], 0x96             ; too large magnitude
        JSR FP0_str_scale
    IFL [FP0], 0x6a             ; too small magnitude
        JSR FP0_str_scale
    SET J, 257
    SET PUSH, J
    JSR FP0_int32
    JSR int_str
    SET J, POP
    SET I, STR3
:FP0_str_iloop
    STI [STR3+J], [I]
    IFN [I], 0
        SET PC, FP0_str_iloop
    STI [STR3+J], 0x002e        ; "."
    JSR FP0_frac
:FP0_str_floop
    IFG J, 266
        SET PC, FP0_str_forceend_rnd
    SET PUSH, J
    SET A, FP_c_1ep1
    JSR FP1_lc
    JSR FP0_mul
    JSR FP0_int32
    ADD A, 0x0030
    SET J, POP
    STI [STR3+J], A
    IFE [FP0], 0                ; 0
        SET PC, FP0_str_forceend
    JSR FP0_frac
    SET PC, FP0_str_floop
:FP0_str_forceend_rnd
    JSR FP0_frac
    IFL [FP0], 0x0080           ; < 0.5
        SET PC, FP0_str_forceend
    SET I, 0
    SET PUSH, J
    SUB J, 1
:FP0_str_rnd_loop
    ADD [STR3+J], 1
    IFL [STR3+J], 0x003A
        SET PC, FP0_str_rnd_end
    SET [STR3+J], 0x0030        ; "0"
    SUB J, 1
    IFL J, 257
        SET PC, FP0_str_rnd_ovf
    IFE [STR3+J], 0x002e        ; "."
        SUB J, 1
    SET PC, FP0_str_rnd_loop
:FP0_str_rnd_ovf
    ; Move entire block forwards
    SET J, PEEK
    SET I, J
    ADD J, 1
:FP0_str_rnd_ovf_loop
    STD [STR3+J], [STR3+I]
    IFG I, 256
        SET PC, FP0_str_rnd_ovf_loop
    SET [STR3+J], 0x31          ; "1"
    SET I, 1
:FP0_str_rnd_end
    SET J, POP
    ADD J, I
:FP0_str_forceend
    SET PUSH, J
    SET B, 0
    ADD J, STR3
    ; remove trailing zeros
    SET [J], 0
    SUB J, 1
:FP0_str_tz
    IFN [J], 0x0030             ; "0"
        SET PC, FP0_str_tz_end
    IFE [J+0xFFFF], 0x002e           ; "."
        SET PC, FP0_str_tz_rm
    SET [J], 0x0000
    SUB J, 1
    ADD B, 1
    SET PC, FP0_str_tz
:FP0_str_tz_rm
    SET [J+0xFFFF], 0
    ADD B, 2
:FP0_str_tz_end
    SET J, POP
    SUB J, B
    IFE [FP0_str_exp], 0
        SET PC, FP0_str_exp0
    IFU [FP0_str_exp], 0
        SET PC, FP0_str_expm
:FP0_str_expp
    STI [STR3+J], 0x0065        ; "e"
    SET PUSH, J
    SET B, 0
    SET A, [FP0_str_exp]
    JSR int_str
    SET J, POP
    SET I, STR3
    SET PC, FP0_str_eloop
:FP0_str_expm
    STI [STR3+J], 0x0065        ; "e"
    STI [STR3+J], 0x002D        ; "-"
    SET PUSH, J
    SET B, 0
    SET A, [FP0_str_exp]
    XOR A, 0xFFFF
    ADD A, 1
    JSR int_str
    SET J, POP
    SET I, STR3
:FP0_str_eloop
    STI [STR3+J], [I]
    IFN [I], 0
        SET PC, FP0_str_eloop
:FP0_str_exp0
    SET [STR3+J], 0
    JSR FP0_load
    JSR FP1_load
    SET I, STR3+256
    SET J, STR3
:FP0_str_copy
    STI [J], [I]
    IFN [I], 0
        SET PC, FP0_str_copy
    SET [J], 0
    SET PC, POP

:FP0_str_scale_zero         ; destroy a return address
    SET 0, POP
:FP0_str_zero
    SET [STR3], [STR3+256]
    SET [STR3+1], 0x0030
    SET [STR3+2], 0x002e
    SET [STR3+3], 0x0030
    SET [STR3+4], 0 ; <nul>
    SET PC, POP

:FP0_str_scale
    IFE [FP0], 0x00             
        SET PC, FP0_str_scale_zero
    IFG [FP0], 0xb0
        SET PC, FP0_str_scale_Em9
    IFL [FP0], 0x50
        SET PC, FP0_str_scale_Ep9
    IFG [FP0], 0x90
        SET PC, FP0_str_scale_Em4
    IFL [FP0], 0x70
        SET PC, FP0_str_scale_Ep4
    IFL [FP0], 0x81
        SET PC, FP0_str_scale_Ep1
    IFG [FP0], 0x84
        SET PC, FP0_str_scale_Em1
    JSR FP0_int
    IFG A, 9
        SET PC, FP0_str_scale_Em1
    IFL [FP0], 0x84
        SET PC, POP
    ; 9.9999999 = 0x84, 0x0, 0x9fff, 0xffe5, 0x280d
    IFG [FP0+2], 0x9fff
        SET PC, FP0_str_scale_Em1_pop
    IFL [FP0+2], 0x9fff
        SET PC, POP
    IFG [FP0+3], 0xffe5
        SET PC, FP0_str_scale_Em1_pop
    IFL [FP0+3], 0xffe5
        SET PC, POP
    IFG [FP0+4], 0x280d
        SET PC, FP0_str_scale_Em1_pop
    IFL [FP0+4], 0x280d
        SET PC, POP
    SET PC, FP0_str_scale_Em1_pop

:FP0_str_scale_Em9
    ADD [FP0_str_exp], 9
    SET A, FP_c_1em9
    JSR FP1_lc
    JSR FP0_mul
    SET PC, FP0_str_scale
:FP0_str_scale_Ep9
    SUB [FP0_str_exp], 9
    SET A, FP_c_1ep9
    JSR FP1_lc
    JSR FP0_mul
    SET PC, FP0_str_scale
:FP0_str_scale_Em4
    ADD [FP0_str_exp], 4
    SET A, FP_c_1em4
    JSR FP1_lc
    JSR FP0_mul
    SET PC, FP0_str_scale
:FP0_str_scale_Ep4
    SUB [FP0_str_exp], 4
    SET A, FP_c_1ep4
    JSR FP1_lc
    JSR FP0_mul
    SET PC, FP0_str_scale
:FP0_str_scale_Em1
    ADD [FP0_str_exp], 1
    SET A, FP_c_1em1
    JSR FP1_lc
    JSR FP0_mul
    SET PC, FP0_str_scale
:FP0_str_scale_Ep1
    SUB [FP0_str_exp], 1
    SET A, FP_c_1ep1
    JSR FP1_lc
    JSR FP0_mul
    SET PC, FP0_str_scale

:FP0_str_scale_Em1_pop
    ADD [FP0_str_exp], 1
    SET A, FP_c_1em1
    JSR FP1_lc
    JSR FP0_mul
    SET PC, POP

; Constants

:FP_c_sqrt2         ; +sqrt(2) ~= 1.41421...
    DAT 0x81, 0x0, 0xb504, 0xf333, 0xf9de
:FP_c_e             ; e ~= 2.71828...
    DAT 0x82, 0x0, 0xadf8, 0x5458, 0xa2bb
:FP_c_ln2           ; +ln(2) ~= 0.69314...
    DAT 0x80, 0x0, 0xb172, 0x17f7, 0xd1cf
:FP_c_atanH         ; +atan(0.5) ~= 0.463647...
    DAT 0x7f, 0x0, 0xed63, 0x382b, 0xdda
:FP_c_atan1         ; +atan(1) ~= 0.78539... (pi/4)
    DAT 0x80, 0x0, 0xc90f, 0xdaa2, 0x2168
:FP_c_halfpi        ; pi/2 ~= 1.57079...
    DAT 0x81, 0x0, 0xc90f, 0xdaa2, 0x2168
:FP_c_pi            ; pi ~= 3.14159...
    DAT 0x82, 0x0, 0xc90f, 0xdaa2, 0x2168
:FP_c_tau           ; 2*pi ~= 6.28318...
    DAT 0x83, 0x0, 0xc90f, 0xdaa2, 0x2168
:FP_c_p1            ; +1.0
    DAT 0x81, 0x0, 0x8000, 0x0, 0x0
:FP_c_m1            ; -1.0
    DAT 0x81, 0xffff, 0x8000, 0x0, 0x0
:FP_c_fracm         ; 1e-14
    DAT 0x52, 0x0, 0xb424, 0xdc35, 0x95c
:FP_c_10expp0       ; 10^+(2^0)
    DAT 0x84, 0x0, 0xa000, 0x0, 0x0
:FP_c_10expp1       ; 10^+(2^1)
    DAT 0x87, 0x0, 0xc800, 0x0, 0x0
:FP_c_10expp2       ; 10^+(2^2)
    DAT 0x8e, 0x0, 0x9c40, 0x0, 0x0
:FP_c_10expp3       ; 10^+(2^3)
    DAT 0x9b, 0x0, 0xbebc, 0x2000, 0x0
:FP_c_10expp4       ; 10^+(2^4)
    DAT 0xb6, 0x0, 0x8e1b, 0xc9bf, 0x400
:FP_c_10expp5       ; 10^+(2^5)
    DAT 0xeb, 0x0, 0x9dc5, 0xada8, 0x2b70
:FP_c_10expm0       ; 10^-(2^0)
    DAT 0x7d, 0x0, 0xcccc, 0xcccc, 0xcccc
:FP_c_10expm1       ; 10^-(2^1)
    DAT 0x7a, 0x0, 0xa3d7, 0xa3d, 0x70a3
:FP_c_10expm2       ; 10^-(2^2)
    DAT 0x73, 0x0, 0xd1b7, 0x1758, 0xe219
:FP_c_10expm3       ; 10^-(2^3)
    DAT 0x66, 0x0, 0xabcc, 0x7711, 0x8461
:FP_c_10expm4       ; 10^-(2^4)
    DAT 0x4b, 0x0, 0xe695, 0x94be, 0xc44d
:FP_c_10expm5       ; 10^-(2^5)
    DAT 0x16, 0x0, 0xcfb1, 0x1ead, 0x4539
:FP_c_1em9          ; 10^(-9)
    DAT 0x63, 0x0, 0x8970, 0x5f41, 0x36b5
:FP_c_1ep9          ; 10^(+9)
    DAT 0x9e, 0x0, 0xee6b, 0x2800, 0x0
:FP_c_1em4          ; 10^(-4)
    DAT 0x73, 0x0, 0xd1b7, 0x1758, 0xe219
:FP_c_1ep4          ; 10^(+4)
    DAT 0x8e, 0x0, 0x9c40, 0x0, 0x0
:FP_c_1em1          ; 10^(-1)
    DAT 0x7d, 0x0, 0xcccc, 0xcccc, 0xcccd
:FP_c_1ep1          ; 10^(+1)
    DAT 0x84, 0x0, 0xa000, 0x0, 0x0
:FP_c_expterms      ; 1/1!, 1/2!, 1/3! ... 1/19!
    DAT 0x81, 0x0, 0x8000, 0x0, 0x0
    DAT 0x80, 0x0, 0x8000, 0x0, 0x0
    DAT 0x7e, 0x0, 0xaaaa, 0xaaaa, 0xaaaa
    DAT 0x7c, 0x0, 0xaaaa, 0xaaaa, 0xaaaa
    DAT 0x7a, 0x0, 0x8888, 0x8888, 0x8888
    DAT 0x77, 0x0, 0xb60b, 0x60b6, 0xb60
    DAT 0x74, 0x0, 0xd00d, 0xd0, 0xd00
    DAT 0x71, 0x0, 0xd00d, 0xd0, 0xd00
    DAT 0x6e, 0x0, 0xb8ef, 0x1d2a, 0xb639
    DAT 0x6b, 0x0, 0x93f2, 0x7dbb, 0xc4fa
    DAT 0x67, 0x0, 0xd732, 0x2b3f, 0xaa27
    DAT 0x64, 0x0, 0x8f76, 0xc77f, 0xc6c4
    DAT 0x60, 0x0, 0xb092, 0x309d, 0x4368
    DAT 0x5c, 0x0, 0xc9cb, 0xa546, 0x3e4
    DAT 0x58, 0x0, 0xd73f, 0x9f39, 0x9dc0
    DAT 0x54, 0x0, 0xd73f, 0x9f39, 0x9dc0
    DAT 0x50, 0x0, 0xca96, 0x3b81, 0x856a
    DAT 0x4c, 0x0, 0xb413, 0xc31d, 0xcbec
    DAT 0x48, 0x0, 0x97a4, 0xda34, 0xa0a
    DAT 0, 0, 0, 0, 0
:FP_c_lnterms      ; 1/1, 1/2, 1/3 ... 1/40
    DAT 0x81, 0x0, 0x8000, 0x0, 0x0
    DAT 0x80, 0x0, 0x8000, 0x0, 0x0
    DAT 0x7f, 0x0, 0xaaaa, 0xaaaa, 0xaaaa
    DAT 0x7f, 0x0, 0x8000, 0x0, 0x0
    DAT 0x7e, 0x0, 0xcccc, 0xcccc, 0xcccc
    DAT 0x7e, 0x0, 0xaaaa, 0xaaaa, 0xaaaa
    DAT 0x7e, 0x0, 0x9249, 0x2492, 0x4924
    DAT 0x7e, 0x0, 0x8000, 0x0, 0x0
    DAT 0x7d, 0x0, 0xe38e, 0x38e3, 0x8e38
    DAT 0x7d, 0x0, 0xcccc, 0xcccc, 0xcccc
    DAT 0x7d, 0x0, 0xba2e, 0x8ba2, 0xe8ba
    DAT 0x7d, 0x0, 0xaaaa, 0xaaaa, 0xaaaa
    DAT 0x7d, 0x0, 0x9d89, 0xd89d, 0x89d8
    DAT 0x7d, 0x0, 0x9249, 0x2492, 0x4924
    DAT 0x7d, 0x0, 0x8888, 0x8888, 0x8888
    DAT 0x7d, 0x0, 0x8000, 0x0, 0x0
    DAT 0x7c, 0x0, 0xf0f0, 0xf0f0, 0xf0f0
    DAT 0x7c, 0x0, 0xe38e, 0x38e3, 0x8e38
    DAT 0x7c, 0x0, 0xd794, 0x35e5, 0xd79
    DAT 0x7c, 0x0, 0xcccc, 0xcccc, 0xcccc
    DAT 0x7c, 0x0, 0xc30c, 0x30c3, 0xc30
    DAT 0x7c, 0x0, 0xba2e, 0x8ba2, 0xe8ba
    DAT 0x7c, 0x0, 0xb216, 0x42c8, 0x590b
    DAT 0x7c, 0x0, 0xaaaa, 0xaaaa, 0xaaaa
    DAT 0x7c, 0x0, 0xa3d7, 0xa3d, 0x70a3
    DAT 0x7c, 0x0, 0x9d89, 0xd89d, 0x89d8
    DAT 0x7c, 0x0, 0x97b4, 0x25ed, 0x97b
    DAT 0x7c, 0x0, 0x9249, 0x2492, 0x4924
    DAT 0x7c, 0x0, 0x8d3d, 0xcb08, 0xd3dc
    DAT 0x7c, 0x0, 0x8888, 0x8888, 0x8888
    DAT 0x7c, 0x0, 0x8421, 0x842, 0x1084
    DAT 0x7c, 0x0, 0x8000, 0x0, 0x0
    DAT 0x7b, 0x0, 0xf83e, 0xf83, 0xe0f8
    DAT 0x7b, 0x0, 0xf0f0, 0xf0f0, 0xf0f0
    DAT 0x7b, 0x0, 0xea0e, 0xa0ea, 0xea0
    DAT 0x7b, 0x0, 0xe38e, 0x38e3, 0x8e38
    DAT 0x7b, 0x0, 0xdd67, 0xc8a6, 0xdd6
    DAT 0x7b, 0x0, 0xd794, 0x35e5, 0xd79
    DAT 0x7b, 0x0, 0xd20d, 0x20d2, 0xd20
    DAT 0x7b, 0x0, 0xcccc, 0xcccc, 0xcccc
    DAT 0, 0, 0, 0, 0
:FP_c_atanterms    ; 1/1, -1/3, +1/5, -1/7 ... +1/37
    DAT 0x81, 0x0, 0x8000, 0x0, 0x0
    DAT 0x7f, 0xffff, 0xaaaa, 0xaaaa, 0xaaaa
    DAT 0x7e, 0x0, 0xcccc, 0xcccc, 0xcccc
    DAT 0x7e, 0xffff, 0x9249, 0x2492, 0x4924
    DAT 0x7d, 0x0, 0xe38e, 0x38e3, 0x8e38
    DAT 0x7d, 0xffff, 0xba2e, 0x8ba2, 0xe8ba
    DAT 0x7d, 0x0, 0x9d89, 0xd89d, 0x89d8
    DAT 0x7d, 0xffff, 0x8888, 0x8888, 0x8888
    DAT 0x7c, 0x0, 0xf0f0, 0xf0f0, 0xf0f0
    DAT 0x7c, 0xffff, 0xd794, 0x35e5, 0xd79
    DAT 0x7c, 0x0, 0xc30c, 0x30c3, 0xc30
    DAT 0x7c, 0xffff, 0xb216, 0x42c8, 0x590b
    DAT 0x7c, 0x0, 0xa3d7, 0xa3d, 0x70a3
    DAT 0x7c, 0xffff, 0x97b4, 0x25ed, 0x97b
    DAT 0x7c, 0x0, 0x8d3d, 0xcb08, 0xd3dc
    DAT 0x7c, 0xffff, 0x8421, 0x842, 0x1084
    DAT 0x7b, 0x0, 0xf83e, 0xf83, 0xe0f8
    DAT 0x7b, 0xffff, 0xea0e, 0xa0ea, 0xea0
    DAT 0x7b, 0x0, 0xdd67, 0xc8a6, 0xdd6
    DAT 0, 0, 0, 0, 0
:FP_c_sinterms    ; 1/1!, -1/3!, +1/5!, -1/7! ... +1/33!
    DAT 0x81, 0x0, 0x8000, 0x0, 0x0
    DAT 0x7e, 0xffff, 0xaaaa, 0xaaaa, 0xaaaa
    DAT 0x7a, 0x0, 0x8888, 0x8888, 0x8888
    DAT 0x74, 0xffff, 0xd00d, 0xd0, 0xd00
    DAT 0x6e, 0x0, 0xb8ef, 0x1d2a, 0xb639
    DAT 0x67, 0xffff, 0xd732, 0x2b3f, 0xaa27
    DAT 0x60, 0x0, 0xb092, 0x309d, 0x4368
    DAT 0x58, 0xffff, 0xd73f, 0x9f39, 0x9dc0
    DAT 0x50, 0x0, 0xca96, 0x3b81, 0x856a
    DAT 0x48, 0xffff, 0x97a4, 0xda34, 0xa0a
    DAT 0x3f, 0x0, 0xb8dc, 0x77b6, 0xe7ab
    DAT 0x36, 0xffff, 0xbb0d, 0xa098, 0xb1c0
    DAT 0x2d, 0x0, 0x9f9e, 0x66e8, 0xb2fd
    DAT 0x23, 0xffff, 0xe8d5, 0x8e16, 0xe675
    DAT 0x1a, 0x0, 0x92cf, 0xcc5a, 0x1ac5
    DAT 0x10, 0xffff, 0xa1a6, 0x973c, 0x1fad
    DAT 0x6, 0x0, 0x9cc0, 0x92a6, 0xe86a
    DAT 0, 0, 0, 0, 0

; ===========================
; POINTER TABLES
; ===========================

; Primary statement jump tables
:stmt_table
    DAT STMT_END
    DAT STMT_FOR
    DAT STMT_NEXT
    DAT STMT_DATA
    DAT STMT_INPUT
    DAT STMT_DIM
    DAT STMT_READ
    DAT STMT_LET
    DAT STMT_GOTO
    DAT STMT_RUN
    DAT STMT_IF
    DAT STMT_RESTORE
    DAT STMT_GOSUB
    DAT STMT_RETURN
    DAT NOOP_SR;ERROR
    DAT NOOP_SR;RESUME
    DAT STMT_REM
    DAT STMT_STOP
    DAT NOOP_SR;ON
    DAT NOOP_SR;WAIT
    DAT NOOP_SR;LOAD
    DAT NOOP_SR;SAVE
    DAT STMT_DEF
    DAT STMT_POKE
    DAT NOOP_SR;CLONE
    DAT NOOP_SR;DELETE
    DAT NOOP_SR;RENUM
    DAT NOOP_SR;AUTO
    DAT NOOP_SR;(unused)
    DAT STMT_SYS
    DAT NOOP_SR;DO
    DAT NOOP_SR;LOOP
    DAT STMT_PRINT
    DAT STMT_CLS
    DAT NOOP_SR;MUSIC
    DAT NOOP_SR;GFX
    DAT NOOP_SR;PLOT
    DAT NOOP_SR;MOVE
    DAT NOOP_SR;LINE
    DAT STMT_CONT
    DAT STMT_LIST
    DAT STMT_CLR
    DAT STMT_NEW
    DAT NOOP_SR;TRACE
    DAT NOOP_SR;WIDTH
    DAT STMT_GET
    DAT NOOP_SR;SWAP
    DAT NOOP_SR;BITSET
    DAT NOOP_SR;BITCLR
    DAT NOOP_SR;EXIT

:func_table
    DAT FUNC_SGN
    DAT FUNC_INT
    DAT FUNC_ABS
    DAT FUNC_USR
    DAT FUNC_FRE
    DAT NOOP_SR;POS
    DAT FUNC_SQR
    DAT FUNC_RND
    DAT FUNC_LOG
    DAT FUNC_EXP
    DAT FUNC_COS
    DAT FUNC_SIN
    DAT FUNC_TAN
    DAT FUNC_ATN
    DAT NOOP_SR;ERR
    DAT FUNC_PEEK
    DAT NOOP_SR;SLEEP
    DAT NOOP_SR;TIME
    DAT FUNC_LEN
    DAT NOOP_SR;STR$
    DAT NOOP_SR;VAL
    DAT NOOP_SR;ASC
    DAT NOOP_SR;UCASE$
    DAT NOOP_SR;LCASE$
    DAT FUNC_CHRS
    DAT NOOP_SR;HEX$
    DAT NOOP_SR;BIN$
    DAT NOOP_SR;BITTST
    DAT NOOP_SR;MAX
    DAT NOOP_SR;MIN
    DAT FUNC_PI
    DAT FUNC_TWOPI
    DAT NOOP_SR;TRUE
    DAT NOOP_SR;FALSE
    DAT NOOP_SR;LEFT$
    DAT NOOP_SR;RIGHT$
    DAT NOOP_SR;MID$
    DAT NOOP_SR;INSTR$

:err_table
    DAT 0
    DAT 6
    DAT 11
    DAT 5

:errmsgs
    DAT 0
    DAT err_NONEXT
    DAT err_SNTX
    DAT err_RETURN
    DAT err_DATA
    DAT err_QTY
    DAT err_OVF
    DAT err_MEM
    DAT err_NOLINE
    DAT err_SUBS
    DAT err_REDIM
    DAT err_DIV0
    DAT err_DIRECT
    DAT err_TYPE
    DAT err_LONG
    DAT err_CPLX
    DAT err_CONT
    DAT err_FUNC

; ===========================
; STRINGS
; ===========================

:msg_welcome
    DAT "*** UNIVTEK  020"
    DAT 0x11; <NL>
    DAT "Univtek BASIC 0.6"
    DAT 0x11; <NL>
    DAT "SYS020 for more info"
    DAT 0x11; <NL>
    DAT "keywords in UPPERCASE"
    DAT 0x11; <NL>
    DAT 0   ; <END>
:msg_credits
    DAT "Univtek BASIC by"
    DAT 0x11; <NL>
    DAT "Univtek Corp."
    DAT 0x11; <NL>
    DAT 0x11; <NL>
    DAT "Keyword & function"
    DAT 0x11; <NL>
    DAT "selection inspired by"
    DAT 0x11; <NL>
    DAT "EhBASIC by Lee Davison"
    DAT 0x11; <NL>
    DAT 0x11; <NL>
    DAT "Additional inspiration"
    DAT 0x11; <NL>
    DAT "C= BASIC, Atari BASIC,"
    DAT 0x11; <NL>
    DAT "BBC BASIC"
    DAT 0x11; <NL>
    DAT 0x11; <NL>
    DAT 0   ; <END>
:msg_freemem
    DAT " Words Free"
    DAT 0x11; <NL>
    DAT 0   ; <END>
:msg_ready
    DAT "ok"
    DAT 0x11; <NL>
    DAT 0   ; <END>
:msg_break
:msg_breaklist
    DAT "BREAK"
    DAT 0x11; <NL>
    DAT 0   ; <END>
:msg_breakln
    DAT "BREAK Ln"
    DAT 0   ; <END>
:msg_error
    DAT "Err"
    DAT 0   ; <END>
:msg_error_at
    DAT " Ln"
    DAT 0   ; <END>
:msg_input_invalid
    DAT "PLEASE INPUT AGAIN"
    DAT 0x11; <NL>
    DAT 0   ; <END>

:err_NONEXT
    DAT "NEXT, no FOR"
    DAT 0   ; <END>
:err_SNTX
    DAT "Syntax"
    DAT 0   ; <END>
:err_RETURN
    DAT "RETURN, no GOSUB"
    DAT 0   ; <END>
:err_DATA
    DAT "No more DATA"
    DAT 0   ; <END>
:err_QTY
    DAT "Invalid number"
    DAT 0   ; <END>
:err_OVF
    DAT "Overflow"
    DAT 0   ; <END>
:err_MEM
    DAT "Memory full"
    DAT 0   ; <END>
:err_NOLINE
    DAT "No such line"
    DAT 0   ; <END>
:err_SUBS
    DAT "Bad subscript"
    DAT 0   ; <END>
:err_REDIM
    DAT "Cannot DIM again"
    DAT 0   ; <END>
:err_DIV0
    DAT "Division by 0"
    DAT 0   ; <END>
:err_DIRECT
    DAT "Not in direct mode"
    DAT 0   ; <END>
:err_TYPE
    DAT "Type mismatch"
    DAT 0   ; <END>
:err_LONG
    DAT "String too long"
    DAT 0   ; <END>
:err_CPLX
    DAT "Too complex"
    DAT 0   ; <END>
:err_CONT
    DAT "Unable to CONT"
    DAT 0   ; <END>
:err_FUNC
    DAT "No such FN"
    DAT 0   ; <END>

:tokens
; PRIMARY KEYWORDS
    DAT 0x1000, 3   ; END
    DAT "END"
    DAT 0x1001, 3   ; FOR
    DAT "FOR"
    DAT 0x1002, 4   ; NEXT
    DAT "NEXT"
    DAT 0x1003, 4   ; DATA
    DAT "DATA"
    DAT 0x1004, 5   ; INPUT
    DAT "INPUT"
    DAT 0x1005, 3   ; DIM
    DAT "DIM"
    DAT 0x1006, 4   ; READ
    DAT "READ"
    DAT 0x1007, 3   ; LET
    DAT "LET"
    DAT 0x1008, 4   ; GOTO
    DAT "GOTO"
    DAT 0x1009, 3   ; RUN
    DAT "RUN"
    DAT 0x100a, 2   ; IF
    DAT "IF"
    DAT 0x100b, 7   ; RESTORE
    DAT "RESTORE"
    DAT 0x100c, 5   ; GOSUB
    DAT "GOSUB"
    DAT 0x100d, 6   ; RETURN
    DAT "RETURN"
    DAT 0x100e, 5   ; ERROR
    DAT "ERROR"
    DAT 0x100f, 6   ; RESUME
    DAT "RESUME"
    DAT 0x1010, 3   ; REM
    DAT "REM"
    DAT 0x1011, 4   ; STOP
    DAT "STOP"
    DAT 0x1012, 2   ; ON
    DAT "ON"
    DAT 0x1013, 4   ; WAIT
    DAT "WAIT"
    DAT 0x1014, 4   ; LOAD
    DAT "LOAD"
    DAT 0x1015, 4   ; SAVE
    DAT "SAVE"
    DAT 0x1016, 3   ; DEF
    DAT "DEF"
    DAT 0x1017, 4   ; POKE
    DAT "POKE"
    DAT 0x1018, 5   ; CLONE
    DAT "CLONE"
    DAT 0x1019, 6   ; DELETE
    DAT "DELETE"
    DAT 0x101a, 5   ; RENUM
    DAT "RENUM"
    DAT 0x101b, 4   ; AUTO
    DAT "AUTO"
    DAT 0x101c, 4   ; EXIT
    DAT "EXIT"
    DAT 0x101d, 3   ; SYS
    DAT "SYS"
    DAT 0x101e, 2   ; DO
    DAT "DO"
    DAT 0x101f, 4   ; LOOP
    DAT "LOOP"
    DAT 0x1020, 5   ; PRINT
    DAT "PRINT"
    DAT 0x1021, 3   ; CLS
    DAT "CLS"
    DAT 0x1022, 5   ; MUSIC
    DAT "MUSIC"
    DAT 0x1023, 3   ; GFX
    DAT "GFX"
    DAT 0x1024, 4   ; PLOT
    DAT "PLOT"
    DAT 0x1025, 4   ; MOVE
    DAT "MOVE"
    DAT 0x1026, 4   ; LINE
    DAT "LINE"
    DAT 0x1027, 4   ; CONT
    DAT "CONT"
    DAT 0x1028, 4   ; LIST
    DAT "LIST"
    DAT 0x1029, 3   ; CLR
    DAT "CLR"
    DAT 0x102a, 3   ; NEW
    DAT "NEW"
    DAT 0x102b, 5   ; TRACE
    DAT "TRACE"
    DAT 0x102c, 5   ; WIDTH
    DAT "WIDTH"
    DAT 0x102d, 3   ; GET
    DAT "GET"
    DAT 0x102f, 6   ; BITSET
    DAT "BITSET"
    DAT 0x1030, 6   ; BITCLR
    DAT "BITCLR"
    DAT 0x1031, 4   ; SWAP
    DAT "SWAP"

; SECONDARY KEYWORDS
    DAT 0x2000, 3   ; TAB
    DAT "TAB"
    DAT 0x2001, 4   ; ELSE
    DAT "ELSE"
    DAT 0x2002, 2   ; TO
    DAT "TO"
    DAT 0x2003, 2   ; FN
    DAT "FN"
    DAT 0x2004, 3   ; SPC
    DAT "SPC"
    DAT 0x2005, 4   ; THEN
    DAT "THEN"
    DAT 0x2006, 3   ; NOT
    DAT "NOT"
    DAT 0x2007, 4   ; STEP
    DAT "STEP"
    DAT 0x2008, 5   ; UNTIL
    DAT "UNTIL"
    DAT 0x2009, 5   ; WHILE
    DAT "WHILE"
    DAT 0x200A, 3   ; OFF
    DAT "OFF"

; FUNCTIONS
    DAT 0x3000, 3   ; Function (SGN)
    DAT "SGN"
    DAT 0x3001, 3   ; Function (INT)
    DAT "INT"
    DAT 0x3002, 3   ; Function (ABS)
    DAT "ABS"
    DAT 0x3003, 3   ; Function (USR)
    DAT "USR"
    DAT 0x3004, 3   ; Function (FRE)
    DAT "FRE"
    DAT 0x3005, 3   ; Function (POS)
    DAT "POS"
    DAT 0x3006, 3   ; Function (SQR)
    DAT "SQR"
    DAT 0x3007, 3   ; Function (RND)
    DAT "RND"
    DAT 0x3008, 3   ; Function (LOG)
    DAT "LOG"
    DAT 0x3009, 3   ; Function (EXP)
    DAT "EXP"
    DAT 0x300a, 3   ; Function (COS)
    DAT "COS"
    DAT 0x300b, 3   ; Function (SIN)
    DAT "SIN"
    DAT 0x300c, 3   ; Function (TAN)
    DAT "TAN"
    DAT 0x300d, 3   ; Function (ATN)
    DAT "ATN"
    DAT 0x300e, 3   ; Function (ERR)
    DAT "ERR"
    DAT 0x300f, 4   ; Function (PEEK)
    DAT "PEEK"
    DAT 0x3010, 5   ; Function (SLEEP)
    DAT "SLEEP"
    DAT 0x3011, 4   ; Function (TIME)
    DAT "TIME"
    DAT 0x3012, 3   ; Function (LEN)
    DAT "LEN"
    DAT 0x3013, 4   ; Function (STR$)
    DAT "STR$"
    DAT 0x3014, 3   ; Function (VAL)
    DAT "VAL"
    DAT 0x3015, 3   ; Function (ASC)
    DAT "ASC"
    DAT 0x3016, 6   ; Function (UCASE$)
    DAT "UCASE$"
    DAT 0x3017, 6   ; Function (LCASE$)
    DAT "LCASE$"
    DAT 0x3018, 4   ; Function (CHR$)
    DAT "CHR$"
    DAT 0x3019, 4   ; Function (HEX$)
    DAT "HEX$"
    DAT 0x301a, 4   ; Function (BIN$)
    DAT "BIN$"
    DAT 0x301b, 6   ; Function (BITTST)
    DAT "BITTST"
    DAT 0x301c, 3   ; Function (MAX)
    DAT "MAX"
    DAT 0x301d, 3   ; Function (MIN)
    DAT "MIN"
    DAT 0x301e, 2   ; Function (PI)
    DAT "PI"
    DAT 0x301f, 5   ; Function (TWOPI)
    DAT "TWOPI"
    DAT 0x3020, 4   ; Function (TRUE)
    DAT "TRUE"
    DAT 0x3021, 5   ; Function (FALSE)
    DAT "FALSE"
    DAT 0x3022, 5   ; Function (LEFT$)
    DAT "LEFT$"
    DAT 0x3023, 6   ; Function (RIGHT$)
    DAT "RIGHT$"
    DAT 0x3024, 4   ; Function (MID$)
    DAT "MID$"
    DAT 0x3025, 6   ; Function (INSTR$)
    DAT "INSTR$"
:tokens_op
; OPERATORS
    DAT 0x4000, 1   ; Operator (PLUS)
    DAT "+"
    DAT 0x4001, 1   ; Operator (MINUS)
    DAT "-"
    DAT 0x4002, 1   ; Operator (MUL)
    DAT "*"
    DAT 0x4003, 1   ; Operator (DIV)
    DAT "/"
    DAT 0x4004, 1   ; Operator (POWER)
    DAT "^"
    DAT 0x4005, 3   ; Operator (AND)
    DAT "AND"
    DAT 0x4006, 3   ; Operator (XOR)
    DAT "XOR"
    DAT 0x4007, 2   ; Operator (OR)
    DAT "OR"
    DAT 0x4008, 3   ; Operator (IDIV)
    DAT "DIV"
    DAT 0x4009, 3   ; Operator (IMOD)
    DAT "MOD"
    DAT 0x400a, 2   ; Operator (RSHIFT)
    DAT ">>"
    DAT 0x400b, 2   ; Operator (LSHIFT)
    DAT "<<"
    DAT 0x400c, 2   ; Operator (GE)
    DAT ">="
    DAT 0x400d, 2   ; Operator (NEQUAL)
    DAT "<>"
    DAT 0x400e, 2   ; Operator (LE)
    DAT "<="
    DAT 0x400f, 1   ; Operator (GT)
    DAT ">"
    DAT 0x4010, 1   ; Operator (EQUAL)
    DAT "="
    DAT 0x4011, 1   ; Operator (LT)
    DAT "<"

    ; DUPLICATE OF REM
    DAT 0x1010, 1   ; ' (REM)
    DAT "'"
    ; DUPLICATE OF PRINT
    DAT 0x1020, 1   ; ? (PRINT)
    DAT "?"

    DAT 0x0000      ; END OF TOKENS

; ===========================
; HEAP SETUP
; ===========================

.org 0x7000
:PROG_DATA

; ===========================
; UNIVTEK DOS
; ===========================
; The code is assembled at 0x8000
; but is copied to 0x2000 at RAM page 1
; upon startup
.org 0x8000
:DOS_START

:DOS_END

.org 0xf000
:MEM_END

.org 0xf800
:LOOP_STACK         ; BASIC loop value stack
.org 0xf820
:LOOP_STACK_LM      ; BASIC loop value stack (limit)

; Expression stack
; Expression stack contents:
;         0001 xxxx yyyy -> 32-bit integer
;         0002 ssss eeee mmmm mmmm mmmm -> float
;         0003 llll .... .... -> String
.org 0xfb00
:EXPR_STACK         ; BASIC expression value stack
.org 0xfb20
:EXPR_STACK_LM      ; BASIC expression value stack (limit)

.org 0xfd00
:SYS_STACK          ; system stack
.org 0xfd20
:SYS_STACK_LM       ; system stack limit

.org 0xffff
; allow full code execution
    DAT 0
